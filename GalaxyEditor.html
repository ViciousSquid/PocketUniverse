<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Galaxy Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root { --accent: #00ff88; --accent2: #ff6600; --danger: #ff3333; --panel: rgba(10, 10, 12, 0.95); --border: rgba(255,255,255,0.1); }
        body { margin: 0; overflow: hidden; background: #000; color: #e0e0e0; font-family: 'Segoe UI', Roboto, sans-serif; font-size: 13px; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        /* FPS Counter Style */
        #fps-counter {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.5); padding: 4px 8px;
            border: 1px solid #333; border-radius: 4px;
            font-family: monospace; color: #00ff88; font-weight: bold;
            z-index: 20; pointer-events: none;
        }

        .panel { 
            pointer-events: auto; background: var(--panel); backdrop-filter: blur(12px); 
            width: 300px; padding: 0; border-radius: 8px; border: 1px solid var(--border); 
            display: flex; flex-direction: column; 
            max-height: 90vh; transition: height 0.3s;
            box-shadow: 0 8px 40px rgba(0,0,0,0.8); 
            overflow: hidden;
        }
        
        .panel.collapsed { width: auto; max-height: 48px; }
        .panel.collapsed .panel-content { display: none; }
        .panel.collapsed .collapse-btn { transform: rotate(180deg); }

        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; cursor: pointer; background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border); user-select: none;
        }
        .panel-header:hover h2 { color: #fff; text-shadow: 0 0 8px var(--accent); }

        .collapse-btn {
            background: none; border: 1px solid #444; color: #888; width: 24px; height: 24px;
            border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center;
            justify-content: center; transition: all 0.2s; padding: 0;
        }
        .collapse-btn:hover { background: #333; color: #fff; border-color: #666; }

        .panel-content { padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }

        h2 { margin: 0; font-size: 14px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 800; }
        h3 { margin: 10px 0 5px 0; font-size: 11px; color: #888; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 4px; }
        
        button.action-btn { 
            background: #222; color: #fff; border: 1px solid #444; padding: 10px; border-radius: 4px; 
            cursor: pointer; transition: 0.2s; text-transform: uppercase; font-size: 11px; font-weight: bold; width: 100%; 
        }
        button.action-btn:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        button.action-btn.secondary { border-color: #555; }
        button.action-btn.secondary:hover { background: #444; color: #fff; border-color: #666; }
        button.delete-btn { background: #422; border-color: #633; }
        button.delete-btn:hover { background: #f44; color: #fff; }
        button.export-btn { background: #264; border-color: #3a6; }
        button.export-btn:hover { background: var(--accent); color: #000; }

        .system-list { display: flex; flex-direction: column; gap: 2px; max-height: 300px; overflow-y: auto; }
        .system-item { 
            padding: 8px 10px; background: rgba(255,255,255,0.05); border-radius: 4px; 
            cursor: pointer; display: flex; align-items: center; justify-content: space-between;
            border: 1px solid transparent; transition: all 0.1s; 
        }
        .system-item:hover { background: rgba(255,255,255,0.1); }
        .system-item.selected { border-color: var(--accent); background: rgba(0, 255, 136, 0.1); }
        .system-icon { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 6px currentColor; }
        .system-bodies { font-size: 10px; color: #666; }

        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; margin: 4px 0; }
        input[type=text], input[type=number] { 
            background: #1a1a1a; border: 1px solid #333; color: #fff; padding: 8px; 
            border-radius: 4px; width: 100%; box-sizing: border-box; 
        }
        select { width: 100%; background: #222; color: #fff; border: 1px solid #444; padding: 6px; border-radius: 4px; }
        .val { font-family: monospace; color: var(--accent); }
        
        input[type=file] { display: none; }

        /* Toggle switch */
        .toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; }
        .toggle-switch { position: relative; width: 50px; height: 26px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333; transition: .3s; border-radius: 26px;
        }
        .toggle-slider:before {
            position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px;
            background-color: #888; transition: .3s; border-radius: 50%;
        }
        input:checked + .toggle-slider { background-color: var(--accent); }
        input:checked + .toggle-slider:before { transform: translateX(24px); background-color: #000; }

        /* Zoom indicator */
        #zoom-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 10px 20px; border-radius: 8px;
            border: 1px solid var(--border); pointer-events: auto;
            display: flex; align-items: center; gap: 15px; z-index: 10;
        }
        #zoom-indicator .zoom-btn {
            background: #333; border: 1px solid #555; color: #fff; width: 30px; height: 30px;
            border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;
        }
        #zoom-indicator .zoom-btn:hover { background: var(--accent); color: #000; }
        #zoom-level { font-family: monospace; color: var(--accent); min-width: 60px; text-align: center; }

        /* WELCOME SCREEN */
        #welcome {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 450px; text-align: center; color: #fff; pointer-events: none;
            background: rgba(0,0,0,0.9); padding: 40px; border-radius: 16px; border: 1px solid #333;
            box-shadow: 0 0 80px rgba(0,255,136,0.1); z-index: 5;
            transition: opacity 0.5s;
        }
        #welcome.hidden { opacity: 0; pointer-events: none; }
        #welcome h1 { margin: 0 0 10px 0; color: var(--accent); font-weight: 300; letter-spacing: 4px; text-transform: uppercase; }
        #welcome p { color: #888; line-height: 1.6; font-size: 14px; }
        .step { background: #1a1a1a; padding: 12px; margin: 10px 0; border-radius: 4px; border: 1px solid #333; display: flex; align-items: center; gap: 12px; text-align: left; }
        .step-num { background: var(--accent); color: #000; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }

        /* Galaxy Stats */
        #galaxy-stats {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 8px 20px; border-radius: 8px;
            border: 1px solid var(--border); pointer-events: auto;
            font-family: monospace; color: #888; font-size: 11px; z-index: 10;
            display: flex; align-items: center; gap: 15px;
        }
        #galaxy-stats span { color: var(--accent); }
        #galaxy-stats .galaxy-view-btn {
            background: #222; border: 1px solid #444; color: #fff; 
            padding: 6px 12px; border-radius: 4px; cursor: pointer;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
            transition: all 0.2s;
        }
        #galaxy-stats .galaxy-view-btn:hover {
            background: var(--accent); color: #000; border-color: var(--accent);
        }

        /* Spiral arm selector */
        .arm-selector { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 5px; }
        .arm-btn { 
            padding: 6px; font-size: 10px; background: #222; border: 1px solid #444; 
            color: #888; border-radius: 4px; cursor: pointer; 
        }
        .arm-btn:hover { background: #333; color: #fff; }
        .arm-btn.active { background: var(--accent2); color: #000; border-color: var(--accent2); }

        /* Body selection label */
        #body-label {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 12px 24px; border-radius: 8px;
            border: 1px solid var(--accent); pointer-events: none;
            font-family: 'Segoe UI', sans-serif; font-size: 14px; z-index: 15;
            display: none; text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        #body-label .body-name { color: #fff; font-size: 18px; font-weight: bold; margin-bottom: 4px; }
        #body-label .body-type { color: var(--accent); font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        #body-label .body-hint { color: #666; font-size: 10px; margin-top: 6px; }

        /* DISASTER TOAST */
        #disaster-toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%) scale(0.9);
            background: rgba(255, 20, 20, 0.95); border: 2px solid #ff5555;
            color: #fff; padding: 15px 40px; border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.6);
            opacity: 0; pointer-events: none; z-index: 100;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            min-width: 300px;
        }
        #disaster-toast.active { opacity: 1; transform: translateX(-50%) scale(1); pointer-events: auto; }
        #disaster-toast:hover { background: rgba(255, 50, 50, 1); transform: translateX(-50%) scale(1.05); }
        
        #disaster-title { font-weight: 900; font-size: 20px; letter-spacing: 2px; text-transform: uppercase; text-shadow: 0 2px 0 #800; }
        #disaster-details { font-weight: normal; font-size: 14px; max-width: 400px; line-height: 1.4; display: none; }
        #disaster-hint { font-size: 10px; text-transform: uppercase; opacity: 0.8; margin-top: 5px; font-weight: bold; letter-spacing: 1px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="fps-counter">FPS: 0</div>

    <div id="disaster-toast">
        <div id="disaster-title">‚ö†Ô∏è Disaster! Collision Detected!</div>
        <div id="disaster-details"></div>
        <div id="disaster-hint">Click to View Site</div>
    </div>

    <div id="welcome">
        <h1>üåå Galaxy Editor</h1>
        <p>Assemble your solar systems into a galaxy with spiral arms.</p>
        
        <div class="step">
            <div class="step-num">1</div>
            <div><strong>Import Solar Systems:</strong> Load <em>solarsystem_*.zip</em> files or build from individual body ZIPs.</div>
        </div>
        <div class="step">
            <div class="step-num">2</div>
            <div><strong>Position in Galaxy:</strong> Drag systems or assign them to spiral arms. Adjust distance from core.</div>
        </div>
        <div class="step">
            <div class="step-num">3</div>
            <div><strong>Toggle Detail View:</strong> Switch between icons and full 3D solar systems with orbiting planets!</div>
        </div>
        <div class="step">
            <div class="step-num">4</div>
            <div><strong>Export Galaxy:</strong> Save your entire galaxy as a single file.</div>
        </div>
    </div>

    <div id="galaxy-stats">
        <button class="galaxy-view-btn" id="btnGalaxyView">üåå Galaxy View</button>
        <span style="color: #444;">|</span>
        Systems: <span id="statSystems">0</span> | 
        Bodies: <span id="statBodies">0</span> | 
        Radius: <span id="statRadius">0</span> ly
    </div>

    <div id="ui-layer">
        <div class="panel" id="leftPanel">
            <div class="panel-header" onclick="togglePanel('leftPanel')">
                <h2>Galaxy</h2>
                <button class="collapse-btn">‚ñº</button>
            </div>
            <div class="panel-content">
                <h3>Import</h3>
                <button id="btnReceiveSystems" class="action-btn" style="display:none; background: linear-gradient(135deg, #9933ff, #cc66ff); color: #fff; border: none; font-weight: bold; margin-bottom: 8px;">
                    üì• Import from System Editor <span id="stagedSystemCount" style="background:#000;color:#9933ff;padding:2px 6px;border-radius:10px;margin-left:5px;font-size:10px;">0</span>
                </button>
                
                <button id="btnImportSystem" class="action-btn">üì¶ Import Solar System</button>
                <button id="btnImportBodies" class="action-btn secondary">‚≠ê Import Bodies (Build System)</button>
                <button id="btnRandomSystem" class="action-btn" style="background: #442; border-color: #664;">üé≤ Generate Random System</button>
                <input type="file" id="fileInputSystem" accept=".zip" multiple>
                <input type="file" id="fileInputBodies" accept=".zip" multiple>
                
                <h3>Solar Systems</h3>
                <div id="systemList" class="system-list">
                    <div style="color:#666; text-align:center; padding: 20px; font-size: 12px;">
                        No systems imported yet
                    </div>
                </div>

                <h3>View Mode</h3>
                <div class="toggle-row">
                    <label>Show Detailed Systems</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleDetailView" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="control-row"><label>System Scale</label><span id="systemScaleVal" class="val">3.0</span></div>
                <input type="range" id="systemScale" min="1" max="10" step="0.5" value="3">

                <h3>Galaxy Shape</h3>
                <div class="control-row"><label>Galaxy Name</label></div>
                <input type="text" id="galaxyName" value="Andromeda" placeholder="Galaxy Name">
                
                <div class="control-row" style="margin-top: 10px;"><label>Spiral Arms</label><span id="armCountVal" class="val">4</span></div>
                <input type="range" id="armCount" min="2" max="8" step="1" value="4">
                
                <div class="control-row"><label>Arm Tightness</label><span id="armTightnessVal" class="val">0.50</span></div>
                <input type="range" id="armTightness" min="0.1" max="1.5" step="0.05" value="0.5">

                <h3>Export</h3>
                <button id="btnExportGalaxy" class="action-btn export-btn">üíæ Export Galaxy</button>
            </div>
        </div>

        <div class="panel" id="detailPanel" style="display:none;">
            <div class="panel-header" onclick="togglePanel('detailPanel')">
                <h2 id="detailName">System Details</h2>
                <button class="collapse-btn">‚ñº</button>
            </div>
            
            <div class="panel-content">
                <h3>System Name</h3>
                <input type="text" id="systemName" placeholder="System Name">

                <h3>Galactic Position</h3>
                <div class="control-row"><label>Distance from Core</label><span id="distCoreVal" class="val">0</span> ly</div>
                <input type="range" id="distCore" min="0" max="500" step="1">
                
                <div class="control-row"><label>Angle</label><span id="angleVal" class="val">0</span>¬∞</div>
                <input type="range" id="angle" min="0" max="360" step="1">

                <h3>Spiral Arm</h3>
                <div class="arm-selector" id="armSelector"></div>

                <h3>Bodies in System</h3>
                <div id="bodyList" class="system-list" style="max-height: 150px;"></div>

                <button class="action-btn delete-btn" id="btnDeleteSystem" style="margin-top: 15px;">üóëÔ∏è Remove System</button>
            </div>
        </div>
    </div>

    <div id="zoom-indicator">
        <button class="zoom-btn" id="btnZoomOut">‚àí</button>
        <span id="zoom-level">100%</span>
        <button class="zoom-btn" id="btnZoomIn">+</button>
        <span style="color:#666; margin-left: 10px;">|</span>
        <button class="zoom-btn" id="btnResetView" style="width: auto; padding: 0 10px; font-size: 11px;">‚åÇ</button>
    </div>

    <div id="body-label">
        <div class="body-name" id="bodyLabelName">Planet Name</div>
        <div class="body-type" id="bodyLabelType">Planet</div>
        <div class="body-hint">Press ESC to return</div>
    </div>

    <script>
        function togglePanel(id) {
            const panel = document.getElementById(id);
            panel.classList.toggle('collapsed');
        }

        // --- TOAST NOTIFICATION LOGIC ---
        let toastTimeout;
        let lastDisasterEvent = null; // Store location and message

        function showDisasterToast(eventData) {
            const toast = document.getElementById('disaster-toast');
            const detailsEl = document.getElementById('disaster-details');
            const hintEl = document.getElementById('disaster-hint');
            
            // Logic handled in module
        }

        // Add Click Listener to Toast
        document.getElementById('disaster-toast').addEventListener('click', () => {
            if (!lastDisasterEvent) return;
            // Logic handled in module
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GLOBAL SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020208);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 400, 300);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 2000;
        controls.minDistance = 5;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.5, 0.3);
        composer.addPass(bloomPass);

        // --- GALAXY CORE ---
        const coreGeo = new THREE.SphereGeometry(8, 32, 32);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.9 });
        const galaxyCore = new THREE.Mesh(coreGeo, coreMat);
        scene.add(galaxyCore);

        const glowGeo = new THREE.SphereGeometry(15, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xffcc66, transparent: true, opacity: 0.3 });
        scene.add(new THREE.Mesh(glowGeo, glowMat));

        // --- BACKGROUND STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(20000 * 3);
        for(let i = 0; i < 20000 * 3; i++) starPos[i] = (Math.random() - 0.5) * 4000;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.4 })));

        // --- EXPLOSION SYSTEM (OPTIMIZED) ---
        const explosions = [];
        const debrisGeometry = new THREE.BufferGeometry();
        // Create a generic debris particle geometry (increased count)
        const debrisCount = 1000; 
        const debrisPos = new Float32Array(debrisCount * 3);
        
        for(let i=0; i<debrisCount; i++) {
            debrisPos[i*3] = (Math.random()-0.5);
            debrisPos[i*3+1] = (Math.random()-0.5);
            debrisPos[i*3+2] = (Math.random()-0.5);
        }
        debrisGeometry.setAttribute('position', new THREE.BufferAttribute(debrisPos, 3));

        class Explosion {
            constructor(position, color, scale) {
                this.age = 0;
                this.lifespan = 8.0; // Increased to 8s so debris lingers longer
                this.active = true;
                this.flashDuration = 0.5; // Flash fades out VERY fast to not blind user

                // Debris particles
                const geo = debrisGeometry.clone();
                const mat = new THREE.PointsMaterial({
                    color: color,
                    size: scale * 0.4,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                this.particles = new THREE.Points(geo, mat);
                this.particles.position.copy(position);
                
                // Store velocities per instance with higher speed
                this.velocities = [];
                for(let i=0; i<debrisCount; i++) {
                    const speed = 5 + Math.random() * 25; 
                    const v = new THREE.Vector3(
                        (Math.random()-0.5), 
                        (Math.random()-0.5), 
                        (Math.random()-0.5)
                    ).normalize().multiplyScalar(speed * scale);
                    this.velocities.push(v);
                }
                
                scene.add(this.particles);

                // Flash light - SMALLER and LESS INTENSE
                // Radius reduced from 40 to 10, Intensity from 5 to 2
                this.light = new THREE.PointLight(color, 2, scale * 10); 
                this.light.position.copy(position);
                scene.add(this.light);
            }

            update(dt) {
                this.age += dt;
                const progress = this.age / this.lifespan;

                if (progress >= 1) {
                    this.active = false;
                    scene.remove(this.particles);
                    scene.remove(this.light);
                    this.particles.geometry.dispose();
                    this.particles.material.dispose();
                    return;
                }

                // Expand particles
                const positions = this.particles.geometry.attributes.position.array;
                for(let i=0; i<debrisCount; i++) {
                    positions[i*3] += this.velocities[i].x * dt;
                    positions[i*3+1] += this.velocities[i].y * dt;
                    positions[i*3+2] += this.velocities[i].z * dt;
                    
                    // High Drag to make debris "hang" in space
                    this.velocities[i].multiplyScalar(0.96); 
                }
                this.particles.geometry.attributes.position.needsUpdate = true;

                // Debris fades slowly over the longer lifespan
                this.particles.material.opacity = 1 - Math.pow(progress, 3);
                
                // Light flashes quickly then dies
                if (this.age < this.flashDuration) {
                    this.light.intensity = 2 * (1 - (this.age / this.flashDuration));
                } else {
                    this.light.intensity = 0;
                }
            }
        }

        // --- SPIRAL ARM DUST ---
        let spiralParticles = null;
        let spiralArmCount = 4;
        let spiralTightness = 0.5;

        function generateSpiralDust() {
            if (spiralParticles) scene.remove(spiralParticles);

            const count = 50000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const arm = Math.floor(Math.random() * spiralArmCount);
                const armAngle = (arm / spiralArmCount) * Math.PI * 2;
                const dist = Math.pow(Math.random(), 0.5) * 400;
                const spiralAngle = armAngle + dist * spiralTightness * 0.02;
                const spread = (Math.random() - 0.5) * (30 + dist * 0.15);
                
                positions[i * 3] = Math.cos(spiralAngle) * dist + (Math.random() - 0.5) * spread;
                positions[i * 3 + 1] = (Math.random() - 0.5) * (5 + dist * 0.02);
                positions[i * 3 + 2] = Math.sin(spiralAngle) * dist + (Math.random() - 0.5) * spread;
                
                const t = dist / 400;
                colors[i * 3] = 0.7 + t * 0.3;
                colors[i * 3 + 1] = 0.7 - t * 0.4;
                colors[i * 3 + 2] = 1.0 - t * 0.5;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            spiralParticles = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: 0.8, transparent: true, opacity: 0.6, vertexColors: true, blending: THREE.AdditiveBlending
            }));
            scene.add(spiralParticles);
        }
        generateSpiralDust();

        // --- SHADER CODE ---
        const shaderUtils = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0) * 2.0 + 1.0;
                vec4 s1 = floor(b1) * 2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            float fbm(vec3 p, int octaves, float persistence, float lacunarity) {
                float total = 0.0, amplitude = 1.0, frequency = 1.0, maxValue = 0.0;
                for(int i = 0; i < 20; i++) {
                    if (i >= octaves) break;
                    total += snoise(p * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                return total / maxValue;
            }
        `;

        const bodyVertexShader = `
            uniform float radius;
            uniform float heightScale;
            uniform float frequency;
            uniform int octaves;
            uniform float persistence;
            uniform float ridge;
            uniform float warpScale;
            uniform vec3 seedOffset;
            uniform float shapeFactor;
            uniform float isSun;
            uniform float time;
            varying vec3 vPos;
            varying float vElevation;
            varying float vSunNoise;
            ${shaderUtils}
            void main() {
                vec3 sphereP = normalize(position);
                vec3 absP = abs(position);
                float maxC = max(max(absP.x, absP.y), absP.z);
                vec3 boxP = position / maxC;
                vec3 baseDir = mix(sphereP, boxP, shapeFactor);
                vec3 basePos = baseDir * radius;
                vec3 warpPos = sphereP * 0.5 + seedOffset;
                if (isSun > 0.5) warpPos += vec3(time * 0.1);
                float warp = snoise(warpPos) * warpScale;
                vec3 noisePos = (sphereP + vec3(warp)) * frequency + seedOffset;
                if (isSun > 0.5) noisePos += vec3(time * 0.2, -time * 0.1, time * 0.1);
                float n = fbm(noisePos, octaves, persistence, 2.0);
                float r = 1.0 - abs(snoise(noisePos));
                r = pow(r, 3.0);
                float finalNoise = mix(n, r, ridge);
                float displacement = finalNoise * heightScale;
                vec3 finalPos = basePos + normalize(baseDir) * displacement;
                vPos = finalPos;
                vElevation = finalNoise;
                vSunNoise = finalNoise;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }
        `;

        const bodyFragmentShader = `
            uniform float oceanLevel;
            uniform float snowLevel;
            uniform float time;
            uniform float isSun;
            uniform vec3 oceanColor;
            uniform vec3 beachColor;
            uniform vec3 grassColor;
            uniform vec3 rockColor;
            uniform vec3 snowColor;
            varying vec3 vPos;
            varying float vElevation;
            varying float vSunNoise;
            ${shaderUtils}
            void main() {
                if (isSun > 0.5) {
                    float heat = vSunNoise * 0.5 + 0.5;
                    float detail = snoise(vPos * 5.0 + vec3(time)) * 0.1;
                    heat += detail;
                    vec3 hot = vec3(1.0, 1.0, 0.8);
                    vec3 cool = vec3(1.0, 0.4, 0.1);
                    vec3 sunColor = mix(cool, hot, heat);
                    gl_FragColor = vec4(sunColor, 1.0);
                    return;
                }
                float e = vElevation;
                vec3 color;
                if (e < oceanLevel) {
                    color = oceanColor;
                } else if (e < oceanLevel + 0.05) {
                    color = beachColor;
                } else if (e < snowLevel - 0.1) {
                    float t = (e - oceanLevel - 0.05) / (snowLevel - 0.1 - oceanLevel - 0.05);
                    color = mix(grassColor, rockColor, t);
                } else {
                    color = snowColor;
                }
                vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
                vec3 normal = normalize(vPos);
                float diff = max(dot(normal, lightDir), 0.3);
                gl_FragColor = vec4(color * diff, 1.0);
            }
        `;

        // --- HASH FUNCTIONS ---
        function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return [(h1 ^ h2 ^ h3 ^ h4) >>> 0];
        }

        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        // ============================================
        // PLANET LIBRARY SYSTEM
        // ============================================
        
        const planetLibrary = {
            suns: [],
            planets: [],
            moons: [],
            loaded: false,
            loading: false
        };
        
        async function loadPlanetLibrary() {
            if (planetLibrary.loading || planetLibrary.loaded) return;
            planetLibrary.loading = true;
            
            try {
                // Try to fetch manifest from planets folder
                const manifestResponse = await fetch('planets/manifest.json');
                if (!manifestResponse.ok) {
                    console.log('No planets/manifest.json found - using procedural generation');
                    planetLibrary.loading = false;
                    return;
                }
                
                const manifest = await manifestResponse.json();
                console.log(`Loading planet library: ${manifest.name}`);
                
                // Load each body ZIP file
                for (const filename of manifest.bodies) {
                    try {
                        const zipResponse = await fetch(`planets/${filename}`);
                        if (!zipResponse.ok) continue;
                        
                        const zipBlob = await zipResponse.blob();
                        const zip = await JSZip.loadAsync(zipBlob);
                        const jsonStr = await zip.file("planet_data.json").async("string");
                        const data = JSON.parse(jsonStr);
                        
                        // Load heightmap if present
                        let heightmapBase64 = null;
                        const imgFile = zip.file("heightmap.png");
                        if (imgFile) {
                            heightmapBase64 = await imgFile.async("base64");
                        }
                        
                        const bodyEntry = { data, heightmapBase64, filename };
                        
                        // Sort into appropriate category
                        if (data.type === 'sun') {
                            planetLibrary.suns.push(bodyEntry);
                        } else if (data.type === 'moon') {
                            planetLibrary.moons.push(bodyEntry);
                        } else {
                            planetLibrary.planets.push(bodyEntry);
                        }
                        
                        console.log(`  Loaded: ${filename} (${data.type})`);
                    } catch (err) {
                        console.warn(`Failed to load ${filename}:`, err);
                    }
                }
                
                planetLibrary.loaded = true;
                console.log(`Library loaded: ${planetLibrary.suns.length} suns, ${planetLibrary.planets.length} planets, ${planetLibrary.moons.length} moons`);
                
                // Update UI to show library status
                updateLibraryStatus();
                
            } catch (err) {
                console.log('Planet library not available:', err.message);
                updateLibraryStatus(); // Still update to show "procedural" mode
            }
            
            planetLibrary.loading = false;
        }
        
        function updateLibraryStatus() {
            const btn = $('btnRandomSystem');
            if (!btn) return;
            
            const suns = planetLibrary.suns.length;
            const planets = planetLibrary.planets.length;
            const moons = planetLibrary.moons.length;
            const total = suns + planets + moons;
            
            if (total > 0) {
                // Show library count with breakdown on hover
                btn.innerHTML = `üé≤ Generate System <span style="font-size:9px;opacity:0.7;">(${total} in library)</span>`;
                btn.title = `Library: ${suns} sun(s), ${planets} planet(s), ${moons} moon(s)\nMissing types will be procedurally generated.`;
                btn.style.borderColor = '#00ff88';
            } else {
                // No library - purely procedural
                btn.innerHTML = `üé≤ Generate Random System`;
                btn.title = `No planets/ folder found.\nAll bodies will be procedurally generated.`;
            }
        }
        
        function getLibraryBody(type, rng) {
            let pool;
            if (type === 'sun') pool = planetLibrary.suns;
            else if (type === 'moon') pool = planetLibrary.moons;
            else pool = planetLibrary.planets;
            
            if (pool.length === 0) return null;
            
            // Pick a random body from the library
            const idx = Math.floor(rng() * pool.length);
            const entry = pool[idx];
            
            // Clone the data so we don't modify the original
            return {
                data: JSON.parse(JSON.stringify(entry.data)),
                heightmapBase64: entry.heightmapBase64
            };
        }
        
        // Start loading library immediately
        loadPlanetLibrary();

        // --- CELESTIAL BODY CLASS ---
        class CelestialBody {
            constructor(data, parentSystem) {
                this.data = data;
                this.type = data.type || 'planet';
                this.parentSystem = parentSystem;
                this.uuid = THREE.MathUtils.generateUUID();

                const p = data.params;
                const c = data.colors;
                const seedHash = cyrb128(data.seed);
                const rng = mulberry32(seedHash[0]);
                const seedOffset = new THREE.Vector3(rng() * 100, rng() * 100, rng() * 100);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        seedOffset: { value: seedOffset },
                        radius: { value: 1.0 },
                        heightScale: { value: parseFloat(p.heightScale) },
                        frequency: { value: parseFloat(p.frequency) },
                        octaves: { value: parseInt(p.octaves) },
                        persistence: { value: parseFloat(p.persistence) },
                        ridge: { value: parseFloat(p.ridge) },
                        warpScale: { value: parseFloat(p.warpScale) },
                        shapeFactor: { value: data.mode === 'cube' ? 0.7 : 0.0 },
                        oceanLevel: { value: parseFloat(p.oceanLevel) },
                        snowLevel: { value: parseFloat(p.snowLevel) },
                        time: { value: 0 },
                        oceanColor: { value: new THREE.Color(c.ocean) },
                        beachColor: { value: new THREE.Color(c.beach) },
                        grassColor: { value: new THREE.Color(c.grass) },
                        rockColor: { value: new THREE.Color(c.rock) },
                        snowColor: { value: new THREE.Color(c.snow) },
                        isSun: { value: this.type === 'sun' ? 1.0 : 0.0 }
                    },
                    vertexShader: bodyVertexShader,
                    fragmentShader: bodyFragmentShader
                });

                const geo = new THREE.BoxGeometry(1, 1, 1, 32, 32, 32);
                this.mesh = new THREE.Mesh(geo, this.material);

                const baseRadius = parseFloat(p.radius);
                this.baseScale = baseRadius;

                // Orbital properties
                this.orbitDistance = 0;
                this.orbitSpeed = 0.3;
                this.orbitAngle = rng() * Math.PI * 2;

                // Pivot for orbital motion
                this.pivot = new THREE.Group();
                this.holder = new THREE.Group();
                this.pivot.add(this.holder);
                this.holder.add(this.mesh);

                // ======== RANDOM ORBITAL PLANE TILT ========
                const orbitalTiltX = (Math.random() - 0.5) * Math.PI * 0.5;
                const orbitalTiltZ = (Math.random() - 0.5) * Math.PI * 0.5;
                this.pivot.rotation.x = orbitalTiltX;
                this.pivot.rotation.z = orbitalTiltZ;

                // ======== PLANETARY RINGS (10% chance for planets) ========
                this.planetRing = null;
                if (this.type === 'planet' && rng() < 0.1) { // 10% chance
                    const ringInner = baseRadius * 1.5;
                    const ringOuter = baseRadius * 2.5;
                    const ringGeo = new THREE.RingGeometry(ringInner, ringOuter, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(rng(), 0.3, 0.6),
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                    });
                    this.planetRing = new THREE.Mesh(ringGeo, ringMat);
                    
                    // Align ring with the orbital plane
                    this.planetRing.rotation.x = Math.PI / 2 + orbitalTiltX;
                    this.planetRing.rotation.z = orbitalTiltZ;
                    
                    this.holder.add(this.planetRing);
                }

                // ======== TILTED ORBIT RING ========
                const ringGeo = new THREE.RingGeometry(1, 1.02, 64);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0x444444, side: THREE.DoubleSide, transparent: true, opacity: 0.3 
                });
                this.orbitRing = new THREE.Mesh(ringGeo, ringMat);
                this.orbitRing.rotation.x = Math.PI / 2 + orbitalTiltX;
                this.orbitRing.rotation.z = orbitalTiltZ;

                this.childBodies = [];
            }

            setScale(scaleFactor) {
                this.mesh.scale.setScalar(this.baseScale * scaleFactor);
                if (this.planetRing) {
                    this.planetRing.scale.setScalar(scaleFactor);
                }
            }

            update(dt, scaleFactor) {
                this.material.uniforms.time.value += dt;
                this.mesh.rotation.y += dt * 0.3;

                if (this.orbitDistance > 0.1) {
                    this.orbitAngle += this.orbitSpeed * dt * 0.3;
                    this.pivot.rotation.y = this.orbitAngle;
                    this.holder.position.set(this.orbitDistance * scaleFactor, 0, 0);
                    this.orbitRing.visible = true;
                    this.orbitRing.scale.setScalar(this.orbitDistance * scaleFactor);
                } else {
                    this.holder.position.set(0, 0, 0);
                    this.orbitRing.visible = false;
                }
                
                // Update child bodies (moons)
                for (const child of this.childBodies) {
                    child.update(dt, scaleFactor * 0.5);
                }
            }

            dispose() {
                this.mesh.geometry.dispose();
                this.material.dispose();
                this.orbitRing.geometry.dispose();
                this.orbitRing.material.dispose();
                if (this.planetRing) {
                    this.planetRing.geometry.dispose();
                    this.planetRing.material.dispose();
                }
                for (const child of this.childBodies) {
                    child.dispose();
                }
            }
        }

        // --- SOLAR SYSTEM CLASS ---
        class SolarSystem {
            constructor(id, name = 'Unknown System') {
                this.id = id;
                this.name = name;
                this.bodies = [];
                this.bodyTextures = new Map();
                this.celestialBodies = [];
                this.distanceFromCore = 100 + Math.random() * 200;
                this.angle = Math.random() * Math.PI * 2;
                this.spiralArm = -1;
                this.height = (Math.random() - 0.5) * 80; // ¬±40 light years
                
                this.group = new THREE.Group();
                this.detailGroup = new THREE.Group();
                this.detailGroup.visible = false;
                this.group.add(this.detailGroup);
                
                // Icon marker
                const markerGeo = new THREE.SphereGeometry(2, 16, 16);
                this.markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffcc00, transparent: true, opacity: 0.9 
                });
                this.marker = new THREE.Mesh(markerGeo, this.markerMaterial);
                this.group.add(this.marker);
                
                // Selection ring
                const ringGeo = new THREE.RingGeometry(3, 3.5, 32);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88, side: THREE.DoubleSide, transparent: true, opacity: 0 
                });
                this.selectionRing = new THREE.Mesh(ringGeo, ringMat);
                this.selectionRing.rotation.x = Math.PI / 2;
                this.group.add(this.selectionRing);
                
                // Label
                this.labelSprite = this.createLabel(name);
                this.labelSprite.position.y = 5;
                this.group.add(this.labelSprite);
                
                this.updatePosition();
                scene.add(this.group);
            }
            
            createLabel(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, 256, 64);
                ctx.font = 'bold 24px Segoe UI';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText(text, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.8 });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(20, 5, 1);
                return sprite;
            }
            
            updateLabel() {
                this.group.remove(this.labelSprite);
                this.labelSprite.material.map.dispose();
                this.labelSprite.material.dispose();
                this.labelSprite = this.createLabel(this.name);
                this.labelSprite.position.y = 5;
                this.group.add(this.labelSprite);
            }
            
            addBody(data, texture = null) {
                this.bodies.push(data);
                if (texture) this.bodyTextures.set(data.seed, texture);
                
                const sun = this.bodies.find(b => b.type === 'sun');
                if (sun) {
                    this.markerMaterial.color.set(sun.colors.ocean);
                    this.name = sun.seed + ' System';
                    this.updateLabel();
                }
            }
            
            buildDetailView(scaleFactor) {
                this.clearDetailView();
                
                const sortedBodies = [...this.bodies].sort((a, b) => {
                    const order = { sun: 0, planet: 1, moon: 2 };
                    return (order[a.type] || 1) - (order[b.type] || 1);
                });
                
                let planetIndex = 0;
                let lastPlanetBody = null;
                let moonIndex = 0;
                
                for (const bodyData of sortedBodies) {
                    const body = new CelestialBody(bodyData, this);
                    body.setScale(scaleFactor);
                    
                    if (bodyData.type === 'sun') {
                        body.orbitDistance = 0;
                        this.detailGroup.add(body.pivot);
                        this.celestialBodies.push(body);
                    } else if (bodyData.type === 'planet') {
                        body.orbitDistance = 4 + planetIndex * 5;
                        body.orbitSpeed = 0.5 / (planetIndex + 1);
                        this.detailGroup.add(body.pivot);
                        this.detailGroup.add(body.orbitRing);
                        this.celestialBodies.push(body);
                        lastPlanetBody = body;
                        planetIndex++;
                        moonIndex = 0;
                    } else if (bodyData.type === 'moon' && lastPlanetBody) {
                        body.orbitDistance = 1.5 + moonIndex * 1.2;
                        body.orbitSpeed = 1.5;
                        body.setScale(scaleFactor * 0.4);
                        lastPlanetBody.holder.add(body.pivot);
                        lastPlanetBody.holder.add(body.orbitRing);
                        lastPlanetBody.childBodies.push(body);
                        moonIndex++;
                    }
                }
            }
            
            clearDetailView() {
                for (const body of this.celestialBodies) {
                    body.pivot.removeFromParent();
                    body.orbitRing.removeFromParent();
                    body.dispose();
                }
                this.celestialBodies = [];
            }

            // Remove a specific body instance (used by collision system)
            removeBodyInstance(bodyInstance) {
                // Find in celestialBodies or childBodies
                let idx = this.celestialBodies.indexOf(bodyInstance);
                if (idx > -1) {
                    this.celestialBodies.splice(idx, 1);
                    bodyInstance.pivot.removeFromParent();
                    bodyInstance.orbitRing.removeFromParent();
                } else {
                    // Check children (moons)
                    for(const p of this.celestialBodies) {
                        const childIdx = p.childBodies.indexOf(bodyInstance);
                        if (childIdx > -1) {
                            p.childBodies.splice(childIdx, 1);
                            bodyInstance.pivot.removeFromParent();
                            bodyInstance.orbitRing.removeFromParent();
                            break;
                        }
                    }
                }
                
                // Remove from data definition
                const dataIdx = this.bodies.indexOf(bodyInstance.data);
                if (dataIdx > -1) this.bodies.splice(dataIdx, 1);

                bodyInstance.dispose();
                updateUI();
            }
            
            setDetailMode(enabled, scaleFactor) {
                this.marker.visible = !enabled;
                this.detailGroup.visible = enabled;
                
                if (enabled && this.celestialBodies.length === 0) {
                    this.buildDetailView(scaleFactor);
                } else if (!enabled) {
                    this.clearDetailView();
                }
            }
            
            updateDetailScale(scaleFactor) {
                if (this.detailGroup.visible && this.bodies.length > 0) {
                    this.clearDetailView();
                    this.buildDetailView(scaleFactor);
                }
            }
            
            updatePosition() {
                let x, z;
                if (this.spiralArm >= 0) {
                    const armAngle = (this.spiralArm / spiralArmCount) * Math.PI * 2;
                    const spiralAngle = armAngle + this.distanceFromCore * spiralTightness * 0.02;
                    x = Math.cos(spiralAngle) * this.distanceFromCore;
                    z = Math.sin(spiralAngle) * this.distanceFromCore;
                } else {
                    x = Math.cos(this.angle) * this.distanceFromCore;
                    z = Math.sin(this.angle) * this.distanceFromCore;
                }
                this.group.position.set(x, this.height, z);
            }
            
            setSelected(selected) {
                this.selectionRing.material.opacity = selected ? 0.8 : 0;
                this.marker.scale.setScalar(selected ? 1.3 : 1);
            }
            
            update(dt, scaleFactor) {
                for (const body of this.celestialBodies) {
                    body.update(dt, scaleFactor);
                }
            }
            
            getExportData() {
                return {
                    name: this.name,
                    distanceFromCore: this.distanceFromCore,
                    angle: this.angle,
                    spiralArm: this.spiralArm,
                    bodies: this.bodies
                };
            }
            
            dispose() {
                this.clearDetailView();
                scene.remove(this.group);
                this.marker.geometry.dispose();
                this.markerMaterial.dispose();
                this.selectionRing.geometry.dispose();
                this.selectionRing.material.dispose();
                this.labelSprite.material.map.dispose();
                this.labelSprite.material.dispose();
            }
        }

        // --- APP STATE ---
        const solarSystems = [];
        let selectedSystem = null;
        let systemCounter = 0;
        let detailViewEnabled = true;
        let systemScale = 3.0;

        // Body selection state
        let selectedBody = null;
        let savedCameraState = null;

        // --- UI HELPERS ---
        const $ = (id) => document.getElementById(id);
        const welcomeEl = $('welcome');

        // --- DETAIL VIEW TOGGLE ---
        $('toggleDetailView').onchange = (e) => {
            detailViewEnabled = e.target.checked;
            if (!detailViewEnabled && selectedBody) {
                deselectBody();
            }
            for (const sys of solarSystems) {
                sys.setDetailMode(detailViewEnabled, systemScale);
            }
        };

        $('systemScale').oninput = (e) => {
            systemScale = parseFloat(e.target.value);
            $('systemScaleVal').textContent = systemScale.toFixed(1);
            if (detailViewEnabled) {
                // Deselect body since bodies get rebuilt
                if (selectedBody) deselectBody();
                for (const sys of solarSystems) {
                    sys.updateDetailScale(systemScale);
                }
            }
        };

        // --- IMPORT HANDLERS ---
        $('btnImportSystem').onclick = () => $('fileInputSystem').click();
        $('btnImportBodies').onclick = () => $('fileInputBodies').click();

        // --- RANDOM GENERATION (matching PlanetEditor logic) ---
        function generateRandomName() {
            const prefixes = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Theta', 'Nova', 'Sol', 'Vega', 'Rigel', 'Sirius', 'Altair', 'Deneb', 'Polaris', 'Antares', 'Proxima', 'Kepler', 'Trappist', 'Gliese'];
            const suffixes = ['Prime', 'Major', 'Minor', 'X', 'IX', 'VII', 'III', 'IV', 'V', 'VI', 'A', 'B', 'C'];
            const numbers = ['', '-1', '-2', '-3', '-4', '-5', ' 47', ' 51', ' 186', ' 442'];
            return prefixes[Math.floor(Math.random() * prefixes.length)] + 
                   (Math.random() > 0.5 ? ' ' + suffixes[Math.floor(Math.random() * suffixes.length)] : '') +
                   numbers[Math.floor(Math.random() * numbers.length)];
        }

        function generateRandomBodyData(type, rng, isCubeSystem = false) {
            const seed = generateRandomName();
            
            // Base parameters (from PlanetEditor defaults)
            let params = {
                radius: type === 'sun' ? (1.2 + rng() * 0.8).toFixed(2) : 
                        type === 'moon' ? (0.3 + rng() * 0.3).toFixed(2) : 
                        (0.5 + rng() * 0.8).toFixed(2),
                warpScale: (rng() * 0.16).toFixed(2),
                heightScale: type === 'sun' ? '0.030' : (0.04 + rng() * 0.08).toFixed(3),
                frequency: (0.5 + rng() * 2.0).toFixed(2),
                octaves: Math.floor(3 + rng() * 4).toString(),
                persistence: (0.1 + rng() * 0.3).toFixed(2),
                ridge: (rng() * 0.3).toFixed(2),
                oceanLevel: type === 'sun' ? '-1.0' : 
                        type === 'moon' ? '-1.0' : 
                        (0.1 - rng() * 1.5).toFixed(2),
                snowLevel: (0.45 + rng() * 0.3).toFixed(2),
                moistureOffset: ((rng() - 0.5) * 0.6).toFixed(2),
                texMix: '0',
                waterNoise: type === 'planet',
                enableTrees: type === 'planet' && rng() > 0.3,
                treeDensity: type === 'planet' ? Math.floor(rng() * 60).toString() : '0',
                treeSize: '1.0'
            };
            
            // Generate colors based on type (from PlanetEditor randomizeBiomeColors)
            let colors;
            if (type === 'sun') {
                colors = {
                    ocean: '#ffaa00',
                    beach: '#ff8800',
                    grass: '#ff4400',
                    rock: '#aa2200',
                    snow: '#ffffaa'
                };
            } else if (type === 'moon') {
                colors = {
                    ocean: '#000000',
                    beach: '#' + new THREE.Color().setHSL(0, 0, 0.2 + rng() * 0.2).getHexString(),
                    grass: '#' + new THREE.Color().setHSL(0, 0, 0.3 + rng() * 0.2).getHexString(),
                    rock: '#' + new THREE.Color().setHSL(0, 0, 0.5 + rng() * 0.3).getHexString(),
                    snow: '#ffffff'
                };
            } else {
                const oceanH = 180 + rng() * 60;
                const beachH = 30 + rng() * 30;
                const grassH = rng() * 360;
                const rockH = rng() < 0.5 ? 30 + rng() * 20 : 0;
                colors = {
                    ocean: '#' + new THREE.Color().setHSL(oceanH / 360, 0.3 + rng() * 0.4, 0.65 + rng() * 0.2).getHexString(),
                    beach: '#' + new THREE.Color().setHSL(beachH / 360, 0.4 + rng() * 0.3, 0.75 + rng() * 0.15).getHexString(),
                    grass: '#' + new THREE.Color().setHSL(grassH / 360, 0.4 + rng() * 0.4, 0.3 + rng() * 0.3).getHexString(),
                    rock: '#' + new THREE.Color().setHSL(rockH / 360, 0.1 + rng() * 0.2, 0.4 + rng() * 0.2).getHexString(),
                    snow: '#' + new THREE.Color().setHSL(0, 0, 0.9 + rng() * 0.1).getHexString()
                };
            }
            
            let mode = 'quad';
            
            // In rare cube systems, ALL bodies (including suns) are cubes
            if (isCubeSystem) {
                mode = 'cube';
            } else {
                // Otherwise, extremely rare for individual non-sun bodies
                if (type !== 'sun' && rng() < 0.001) { // 0.1%
                    mode = 'cube';
                }
            }
            
            return {
                seed: seed,
                type: type,
                mode: mode,
                hasHeightMap: false,
                params: params,
                colors: colors
            };
        }

        function generateRandomSolarSystem() {
const masterSeed = Date.now();
const seedHash = cyrb128(masterSeed.toString());
const rng = mulberry32(seedHash[0]);

// Create new solar system
const system = new SolarSystem(systemCounter++, 'New System');

// Very rare chance for entire system to be "cube mode"
const isCubeSystem = rng() < 0.01; // 1% chance ‚Äì extremely rare

// Helper: get body from library or generate procedurally
function getOrGenerateBody(type) {
    const libraryBody = getLibraryBody(type, rng);
    if (libraryBody) {
        // Use library body with its texture
        let texture = null;
        if (libraryBody.heightmapBase64) {
            texture = new THREE.TextureLoader().load("data:image/png;base64," + libraryBody.heightmapBase64);
        }
        return { data: libraryBody.data, texture };
    }
    // Fall back to procedural generation
    return { data: generateRandomBodyData(type, rng, isCubeSystem), texture: null };
}

// Generate sun (now can be cube if in cube system)
const sun = getOrGenerateBody('sun');
system.addBody(sun.data, sun.texture);

// Generate 2-6 planets
const numPlanets = 2 + Math.floor(rng() * 5);
for (let i = 0; i < numPlanets; i++) {
    const planet = getOrGenerateBody('planet');
    system.addBody(planet.data, planet.texture);
    
    // 40% chance of having 1-3 moons
    if (rng() > 0.6) {
        const numMoons = 1 + Math.floor(rng() * 3);
        for (let j = 0; j < numMoons; j++) {
            const moon = getOrGenerateBody('moon');
            system.addBody(moon.data, moon.texture);
        }
    }
}

if (detailViewEnabled) {
    system.setDetailMode(true, systemScale);
}

solarSystems.push(system);
updateUI();
selectSystem(system);
}

        $('btnRandomSystem').onclick = generateRandomSolarSystem;

        $('fileInputSystem').onchange = async (e) => {
            const files = Array.from(e.target.files);
            for (const file of files) {
                await importSolarSystemZip(file);
            }
            $('fileInputSystem').value = '';
        };

        $('fileInputBodies').onchange = async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            const system = new SolarSystem(systemCounter++, 'New System');
            
            for (const file of files) {
                try {
                    const zip = await JSZip.loadAsync(file);
                    const jsonStr = await zip.file("planet_data.json").async("string");
                    const data = JSON.parse(jsonStr);
                    
                    let texture = null;
                    const imgFile = zip.file("heightmap.png");
                    if (imgFile) {
                        const b64 = await imgFile.async("base64");
                        texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                    }
                    
                    system.addBody(data, texture);
                } catch (err) {
                    console.error("Error loading body:", err);
                }
            }
            
            if (detailViewEnabled) {
                system.setDetailMode(true, systemScale);
            }
            
            solarSystems.push(system);
            updateUI();
            selectSystem(system);
            
            $('fileInputBodies').value = '';
        };

        async function importSolarSystemZip(file) {
            try {
                const zip = await JSZip.loadAsync(file);
                
                const galaxyFile = zip.file("galaxy_data.json");
                if (galaxyFile) {
                    await importGalaxyZip(zip);
                    return;
                }
                
                const manifestFile = zip.file("system_data.json");
                if (manifestFile) {
                    const manifestStr = await manifestFile.async("string");
                    const manifest = JSON.parse(manifestStr);
                    
                    const system = new SolarSystem(systemCounter++, manifest.name || 'Imported System');
                    system.distanceFromCore = manifest.distanceFromCore || 100;
                    system.angle = manifest.angle || 0;
                    system.spiralArm = manifest.spiralArm ?? -1;
                    
                    for (const bodyInfo of manifest.bodies) {
                        const bodyFile = zip.file(bodyInfo.file);
                        if (bodyFile) {
                            const bodyZip = await JSZip.loadAsync(await bodyFile.async("blob"));
                            const bodyJsonStr = await bodyZip.file("planet_data.json").async("string");
                            const bodyData = JSON.parse(bodyJsonStr);
                            
                            let texture = null;
                            const imgFile = bodyZip.file("heightmap.png");
                            if (imgFile) {
                                const b64 = await imgFile.async("base64");
                                texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                            }
                            
                            system.addBody(bodyData, texture);
                        }
                    }
                    
                    system.updatePosition();
                    if (detailViewEnabled) system.setDetailMode(true, systemScale);
                    solarSystems.push(system);
                } else {
                    const jsonFile = zip.file("planet_data.json");
                    if (jsonFile) {
                        const jsonStr = await jsonFile.async("string");
                        const data = JSON.parse(jsonStr);
                        
                        const system = new SolarSystem(systemCounter++, data.seed + ' System');
                        
                        let texture = null;
                        const imgFile = zip.file("heightmap.png");
                        if (imgFile) {
                            const b64 = await imgFile.async("base64");
                            texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                        }
                        
                        system.addBody(data, texture);
                        if (detailViewEnabled) system.setDetailMode(true, systemScale);
                        solarSystems.push(system);
                    }
                }
                
                updateUI();
            } catch (err) {
                console.error("Error importing solar system:", err);
                alert("Error importing file: " + err.message);
            }
        }

        async function importGalaxyZip(zip) {
            const galaxyStr = await zip.file("galaxy_data.json").async("string");
            const galaxyData = JSON.parse(galaxyStr);
            
            $('galaxyName').value = galaxyData.name || 'Imported Galaxy';
            $('armCount').value = galaxyData.spiralArmCount || 4;
            $('armTightness').value = galaxyData.spiralTightness || 0.5;
            spiralArmCount = galaxyData.spiralArmCount || 4;
            spiralTightness = galaxyData.spiralTightness || 0.5;
            updateArmControls();
            generateSpiralDust();
            
            for (const sysData of galaxyData.systems) {
                const system = new SolarSystem(systemCounter++, sysData.name);
                system.distanceFromCore = sysData.distanceFromCore;
                system.angle = sysData.angle;
                system.spiralArm = sysData.spiralArm;
                
                for (const bodyData of sysData.bodies) {
                    system.addBody(bodyData);
                }
                
                system.updatePosition();
                if (detailViewEnabled) system.setDetailMode(true, systemScale);
                solarSystems.push(system);
            }
            
            updateUI();
        }

        // --- SYSTEM SELECTION ---
        function selectSystem(system) {
            if (selectedSystem) selectedSystem.setSelected(false);
            selectedSystem = system;
            
            if (system) {
                system.setSelected(true);
                $('detailPanel').style.display = 'flex';
                $('detailName').textContent = system.name;
                $('systemName').value = system.name;
                $('distCore').value = system.distanceFromCore;
                $('distCoreVal').textContent = Math.round(system.distanceFromCore);
                $('angle').value = (system.angle * 180 / Math.PI) % 360;
                $('angleVal').textContent = Math.round((system.angle * 180 / Math.PI) % 360);
                
                updateArmSelector(system);
                updateBodyList(system);
            } else {
                $('detailPanel').style.display = 'none';
            }
            
            renderSystemList();
        }

        function updateArmSelector(system) {
            const selector = $('armSelector');
            selector.innerHTML = '';
            
            const freeBtn = document.createElement('button');
            freeBtn.className = 'arm-btn' + (system.spiralArm === -1 ? ' active' : '');
            freeBtn.textContent = 'Free';
            freeBtn.onclick = () => {
                system.spiralArm = -1;
                system.updatePosition();
                updateArmSelector(system);
            };
            selector.appendChild(freeBtn);
            
            for (let i = 0; i < spiralArmCount; i++) {
                const btn = document.createElement('button');
                btn.className = 'arm-btn' + (system.spiralArm === i ? ' active' : '');
                btn.textContent = `Arm ${i + 1}`;
                btn.onclick = () => {
                    system.spiralArm = i;
                    system.updatePosition();
                    updateArmSelector(system);
                };
                selector.appendChild(btn);
            }
        }

        function updateBodyList(system) {
            const list = $('bodyList');
            list.innerHTML = '';
            
            if (system.bodies.length === 0) {
                list.innerHTML = '<div style="color:#666; text-align:center; padding: 10px; font-size: 11px;">No bodies</div>';
                return;
            }
            
            for (const body of system.bodies) {
                const div = document.createElement('div');
                div.className = 'system-item';
                div.style.cursor = 'default';
                const icon = body.type === 'sun' ? '‚òÄÔ∏è' : body.type === 'moon' ? 'üåô' : 'ü™ê';
                div.innerHTML = `<span>${icon} ${body.seed}</span><span style="font-size:10px; color:#666;">${body.type}</span>`;
                list.appendChild(div);
            }
        }

        // --- UI RENDERING ---
        function renderSystemList() {
            const list = $('systemList');
            
            if (solarSystems.length === 0) {
                list.innerHTML = '<div style="color:#666; text-align:center; padding: 20px; font-size: 12px;">No systems imported yet</div>';
                welcomeEl.classList.remove('hidden');
                return;
            }
            
            welcomeEl.classList.add('hidden');
            list.innerHTML = '';
            
            for (const system of solarSystems) {
                const div = document.createElement('div');
                div.className = 'system-item' + (selectedSystem === system ? ' selected' : '');
                
                const sun = system.bodies.find(b => b.type === 'sun');
                const color = sun ? sun.colors.ocean : '#ffcc00';
                
                div.innerHTML = `
                    <div style="display:flex; align-items:center;">
                        <span class="system-icon" style="background:${color}; color:${color}"></span>
                        <span>${system.name}</span>
                    </div>
                    <span class="system-bodies">${system.bodies.length} bodies</span>
                `;
                
                div.onclick = () => selectSystem(system);
                list.appendChild(div);
            }
        }

        function updateUI() {
            renderSystemList();
            updateStats();
        }

        function updateStats() {
            $('statSystems').textContent = solarSystems.length;
            $('statBodies').textContent = solarSystems.reduce((sum, s) => sum + s.bodies.length, 0);
            const maxDist = solarSystems.reduce((max, s) => Math.max(max, s.distanceFromCore), 0);
            $('statRadius').textContent = Math.round(maxDist);
        }

        function updateArmControls() {
            $('armCountVal').textContent = spiralArmCount;
            $('armTightnessVal').textContent = spiralTightness.toFixed(2);
        }

        // --- CONTROL HANDLERS ---
        $('distCore').oninput = (e) => {
            if (!selectedSystem) return;
            selectedSystem.distanceFromCore = parseFloat(e.target.value);
            $('distCoreVal').textContent = Math.round(selectedSystem.distanceFromCore);
            selectedSystem.updatePosition();
            updateStats();
        };

        $('angle').oninput = (e) => {
            if (!selectedSystem) return;
            selectedSystem.angle = parseFloat(e.target.value) * Math.PI / 180;
            $('angleVal').textContent = Math.round(parseFloat(e.target.value));
            selectedSystem.updatePosition();
        };

        $('systemName').oninput = (e) => {
            if (!selectedSystem) return;
            selectedSystem.name = e.target.value;
            selectedSystem.updateLabel();
            $('detailName').textContent = e.target.value;
            renderSystemList();
        };

        $('armCount').oninput = (e) => {
            spiralArmCount = parseInt(e.target.value);
            $('armCountVal').textContent = spiralArmCount;
            generateSpiralDust();
            solarSystems.forEach(s => s.updatePosition());
            if (selectedSystem) updateArmSelector(selectedSystem);
        };

        $('armTightness').oninput = (e) => {
            spiralTightness = parseFloat(e.target.value);
            $('armTightnessVal').textContent = spiralTightness.toFixed(2);
            generateSpiralDust();
            solarSystems.forEach(s => s.updatePosition());
        };

        $('btnDeleteSystem').onclick = () => {
            if (!selectedSystem) return;
            // Deselect body if it was in this system
            if (selectedBody && selectedBody.parentSystem === selectedSystem) {
                deselectBody();
            }
            const idx = solarSystems.indexOf(selectedSystem);
            if (idx > -1) {
                selectedSystem.dispose();
                solarSystems.splice(idx, 1);
            }
            selectedSystem = null;
            $('detailPanel').style.display = 'none';
            updateUI();
        };

        // --- EXPORT ---
        $('btnExportGalaxy').onclick = async () => {
            const zip = new JSZip();
            const galaxyData = {
                name: $('galaxyName').value,
                spiralArmCount: spiralArmCount,
                spiralTightness: spiralTightness,
                systems: solarSystems.map(s => s.getExportData())
            };
            zip.file("galaxy_data.json", JSON.stringify(galaxyData, null, 2));
            
            const blob = await zip.generateAsync({ type: "blob" });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `galaxy_${$('galaxyName').value.replace(/\s+/g, '_')}.zip`;
            link.click();
        };

        // --- ZOOM CONTROLS ---
        function updateZoomDisplay() {
            const dist = camera.position.length();
            const percent = Math.round((1000 / dist) * 100);
            $('zoom-level').textContent = Math.min(percent, 9999) + '%';
        }

        $('btnZoomIn').onclick = () => {
            camera.position.multiplyScalar(0.7);
            controls.update();
            updateZoomDisplay();
        };

        $('btnZoomOut').onclick = () => {
            camera.position.multiplyScalar(1.4);
            controls.update();
            updateZoomDisplay();
        };

        $('btnResetView').onclick = () => {
            camera.position.set(0, 400, 300);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
            updateZoomDisplay();
        };

        $('btnGalaxyView').onclick = () => {
            // Deselect any selected body
            if (selectedBody) {
                $('body-label').style.display = 'none';
                selectedBody = null;
                savedCameraState = null;
            }
            // Animate to initial galaxy view
            animateCameraToPosition(
                new THREE.Vector3(0, 400, 300),
                new THREE.Vector3(0, 0, 0)
            );
        };

        controls.addEventListener('change', updateZoomDisplay);

        // --- RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Body selection functions
        function selectBody(body, system) {
            // Save camera state before zooming
            savedCameraState = {
                position: camera.position.clone(),
                target: controls.target.clone()
            };
            
            selectedBody = body;
            selectedSystem = system;
            
            // Show label
            const bodyLabel = $('body-label');
            $('bodyLabelName').textContent = body.data.seed;
            $('bodyLabelType').textContent = body.type.charAt(0).toUpperCase() + body.type.slice(1);
            bodyLabel.style.display = 'block';
            
            // Animate camera to body
            animateCameraToBody(body, system);
        }

        function deselectBody() {
            if (!selectedBody) return;
            
            // Hide label
            $('body-label').style.display = 'none';
            
            // Restore camera
            if (savedCameraState) {
                animateCameraToPosition(savedCameraState.position, savedCameraState.target);
                savedCameraState = null;
            }
            
            selectedBody = null;
        }

        function getBodyWorldPosition(body, system) {
            // Get the world position of the body mesh
            const worldPos = new THREE.Vector3();
            body.mesh.getWorldPosition(worldPos);
            return worldPos;
        }

        function animateCameraToBody(body, system) {
            const targetPos = getBodyWorldPosition(body, system);
            
            // Calculate view distance based on body size
            const bodySize = body.baseScale * systemScale;
            const viewDistance = Math.max(bodySize * 6, 5);
            
            // Calculate new camera position (offset from body)
            const offset = new THREE.Vector3(viewDistance * 0.7, viewDistance * 0.5, viewDistance * 0.7);
            const newCamPos = targetPos.clone().add(offset);
            
            animateCameraToPosition(newCamPos, targetPos);
        }

        function animateCameraToPosition(newPosition, newTarget) {
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 500;
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                
                camera.position.lerpVectors(startPos, newPosition, ease);
                controls.target.lerpVectors(startTarget, newTarget, ease);
                controls.update();
                updateZoomDisplay();
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        // Click handler
        renderer.domElement.addEventListener('click', (e) => {
            if (e.target !== renderer.domElement) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Build list of clickable objects
            const clickables = [];
            for (const sys of solarSystems) {
                // Add system marker
                clickables.push({ obj: sys.marker, sys, body: null });
                
                // Add celestial bodies (when in detail view)
                if (detailViewEnabled) {
                    for (const body of sys.celestialBodies) {
                        clickables.push({ obj: body.mesh, sys, body });
                        // Add child bodies (moons)
                        for (const child of body.childBodies) {
                            clickables.push({ obj: child.mesh, sys, body: child });
                        }
                    }
                }
            }
            
            const intersects = raycaster.intersectObjects(clickables.map(c => c.obj));
            
            if (intersects.length > 0) {
                const hit = clickables.find(c => c.obj === intersects[0].object);
                if (hit) {
                    if (hit.body) {
                        // Clicked on a celestial body
                        selectBody(hit.body, hit.sys);
                        selectSystem(hit.sys);
                    } else {
                        // Clicked on system marker
                        if (selectedBody) deselectBody();
                        selectSystem(hit.sys);
                    }
                }
            } else {
                // Clicked on empty space - deselect body but keep system
                if (selectedBody) deselectBody();
            }
        });

        renderer.domElement.addEventListener('dblclick', (e) => {
            if (e.target !== renderer.domElement) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const clickables = [];
            for (const sys of solarSystems) {
                clickables.push({ obj: sys.marker, sys });
                for (const body of sys.celestialBodies) {
                    clickables.push({ obj: body.mesh, sys });
                }
            }
            
            const intersects = raycaster.intersectObjects(clickables.map(c => c.obj));
            
            if (intersects.length > 0) {
                const hit = clickables.find(c => c.obj === intersects[0].object);
                if (hit) {
                    const pos = hit.sys.group.position.clone();
                    controls.target.copy(pos);
                    camera.position.set(pos.x, pos.y + 30, pos.z + 50);
                    updateZoomDisplay();
                }
            }
        });

        // ESC key handler
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (selectedBody) {
                    deselectBody();
                }
            }
        });

        // --- COLLISION DETECTION ---
        const worldPosA = new THREE.Vector3();
        const worldPosB = new THREE.Vector3();

        function checkCollisions() {
            // Only relevant in detail view where meshes exist
            if (!detailViewEnabled) return;
            
            // THROTTLING: If too many explosions are active, stop checking for collisions to prevent crash
            if (explosions.length >= 5) return; 

            const allBodies = [];
            
            // 1. Flatten all active bodies into a single array with world coords
            solarSystems.forEach(sys => {
                const bodies = [ ...sys.celestialBodies ];
                sys.celestialBodies.forEach(b => bodies.push(...b.childBodies));
                
                bodies.forEach(body => {
                    body.mesh.getWorldPosition(worldPosA);
                    allBodies.push({
                        instance: body,
                        system: sys,
                        pos: worldPosA.clone(),
                        radius: body.baseScale * systemScale
                    });
                });
            });

            // 2. Check collisions
            const toDestroy = new Set();
            let collisionOccurred = false;
            let collisionPos = new THREE.Vector3();
            let collisionMsg = "";

            for (let i = 0; i < allBodies.length; i++) {
                const a = allBodies[i];
                for (let j = i + 1; j < allBodies.length; j++) {
                    const b = allBodies[j];
                    
                    if (a.system === b.system) continue;

                    const distSq = a.pos.distanceToSquared(b.pos);
                    const radiiSum = (a.radius + b.radius) * 0.8; 
                    
                    if (distSq < radiiSum * radiiSum) {
                        toDestroy.add(a);
                        toDestroy.add(b);
                        
                        const midPoint = a.pos.clone().add(b.pos).multiplyScalar(0.5);
                        
                        const colA = new THREE.Color(a.instance.data.colors.ocean);
                        const colB = new THREE.Color(b.instance.data.colors.rock || b.instance.data.colors.ocean);
                        const mixCol = colA.lerp(colB, 0.5);
                        mixCol.offsetHSL(0, 0, 0.2); 
                        
                        explosions.push(new Explosion(midPoint, mixCol, a.radius + b.radius));
                        collisionOccurred = true;
                        
                        collisionPos.copy(midPoint);
                        collisionMsg = `${a.instance.data.seed} collided with ${b.instance.data.seed}`;
                    }
                }
            }

            // 3. Remove destroyed bodies and Show Toast
            if (collisionOccurred) {
                // Update Toast manually
                const toast = document.getElementById('disaster-toast');
                const detailsEl = document.getElementById('disaster-details');
                const hintEl = document.getElementById('disaster-hint');
                
                lastDisasterEvent = { position: collisionPos, message: collisionMsg };

                detailsEl.style.display = 'none';
                detailsEl.textContent = collisionMsg;
                hintEl.style.display = 'block';
                
                toast.classList.add('active');
                
                if (toastTimeout) clearTimeout(toastTimeout);
                toastTimeout = setTimeout(() => {
                    toast.classList.remove('active');
                }, 8000); 
                
                toDestroy.forEach(item => {
                    if (selectedBody === item.instance) deselectBody();
                    item.system.removeBodyInstance(item.instance);
                });
                
                updateUI();
            }
        }
        
        // Add Click Listener to Toast inside module
        document.getElementById('disaster-toast').addEventListener('click', () => {
            if (!lastDisasterEvent) return;
            document.getElementById('disaster-details').style.display = 'block';
            document.getElementById('disaster-hint').style.display = 'none';
            const targetPos = lastDisasterEvent.position;
            const cameraOffset = new THREE.Vector3(20, 15, 20);
            const newCamPos = targetPos.clone().add(cameraOffset);
            if (selectedBody) deselectBody();
            animateCameraToPosition(newCamPos, targetPos);
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        
        // FPS Counter
        const fpsEl = document.getElementById('fps-counter');
        let frames = 0;
        let lastTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS Update
            frames++;
            const timeNow = performance.now();
            if (timeNow >= lastTime + 1000) {
                fpsEl.innerText = 'FPS: ' + Math.round((frames * 1000) / (timeNow - lastTime));
                frames = 0;
                lastTime = timeNow;
            }
            
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            
            galaxyCore.rotation.y += dt * 0.1;
            
            if (spiralParticles) {
                spiralParticles.rotation.y += dt * 0.002;
            }
            
            if (detailViewEnabled) {
                for (const sys of solarSystems) {
                    sys.update(dt, systemScale);
                }
                
                if (selectedBody && savedCameraState) {
                    const targetPos = getBodyWorldPosition(selectedBody, selectedSystem);
                    controls.target.copy(targetPos);
                }
                
                checkCollisions();
            }
            
            // Update Explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].update(dt);
                if (!explosions[i].active) {
                    explosions.splice(i, 1);
                }
            }
            
            if (selectedSystem) {
                const pulse = 0.8 + Math.sin(time * 4) * 0.2;
                selectedSystem.selectionRing.material.opacity = pulse;
            }
            
            controls.update();
            composer.render();
        }
        
        animate();
        updateZoomDisplay();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // EMBEDDED MODE SUPPORT
        // ============================================
        
        const isEmbedded = window.parent !== window || new URLSearchParams(window.location.search).has('embedded');
        let stagedSystems = [];
        
        if (isEmbedded) {
            $('btnReceiveSystems').style.display = 'block';
            $('btnImportSystem').style.fontSize = '10px';
            $('btnImportSystem').style.padding = '6px';
            $('btnImportBodies').style.fontSize = '10px';
            $('btnImportBodies').style.padding = '6px';
            $('btnExportGalaxy').style.fontSize = '10px';
            $('btnExportGalaxy').style.padding = '6px';
            window.parent.postMessage({ type: 'REQUEST_STAGED_SYSTEMS' }, '*');
        }
        
        window.addEventListener('message', (event) => {
            const { type, data } = event.data || {};
            if (type === 'RECEIVE_SYSTEMS') {
                stagedSystems = data || [];
                updateStagedSystemCount();
            }
            if (type === 'EDITOR_ACTIVATED' && isEmbedded) {
                window.parent.postMessage({ type: 'REQUEST_STAGED_SYSTEMS' }, '*');
            }
        });
        
        function updateStagedSystemCount() {
            const countEl = $('stagedSystemCount');
            if (countEl) {
                countEl.textContent = stagedSystems.length;
                $('btnReceiveSystems').style.opacity = stagedSystems.length > 0 ? '1' : '0.5';
            }
        }
        
        $('btnReceiveSystems').onclick = () => {
            if (stagedSystems.length === 0) {
                alert('No systems staged! Create solar systems in the System Editor first and click "Send to Galaxy Editor".');
                return;
            }
            for (const sysData of stagedSystems) {
                const system = new SolarSystem(systemCounter++, sysData.name);
                system.distanceFromCore = sysData.distanceFromCore || (50 + Math.random() * 150);
                system.angle = sysData.angle || Math.random() * Math.PI * 2;
                system.spiralArm = sysData.spiralArm ?? -1;
                for (const bodyInfo of sysData.bodies) {
                    let texture = null;
                    if (bodyInfo.heightmapBase64) {
                        texture = new THREE.TextureLoader().load("data:image/png;base64," + bodyInfo.heightmapBase64);
                    }
                    system.addBody(bodyInfo.data, texture);
                }
                system.updatePosition();
                if (detailViewEnabled) {
                    system.setDetailMode(true, systemScale);
                }
                solarSystems.push(system);
            }
            updateUI();
            window.parent.postMessage({ type: 'CLEAR_STAGED_SYSTEMS' }, '*');
            stagedSystems = [];
            updateStagedSystemCount();
            const btn = $('btnReceiveSystems');
            btn.textContent = '‚úì Imported!';
            btn.style.background = 'linear-gradient(135deg, #00ff88, #00cc66)';
            setTimeout(() => {
                btn.innerHTML = 'üì• Import from System Editor <span id="stagedSystemCount" style="background:#000;color:#9933ff;padding:2px 6px;border-radius:10px;margin-left:5px;font-size:10px;">0</span>';
            }, 1500);
        };
    </script>
</body>
</html>