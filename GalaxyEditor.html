<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Galaxy Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root { --accent: #00ff88; --accent2: #ff6600; --panel: rgba(10, 10, 12, 0.95); --border: rgba(255,255,255,0.1); }
        body { margin: 0; overflow: hidden; background: #000; color: #e0e0e0; font-family: 'Segoe UI', Roboto, sans-serif; font-size: 13px; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        .panel { 
            pointer-events: auto; background: var(--panel); backdrop-filter: blur(12px); 
            width: 300px; padding: 0; border-radius: 8px; border: 1px solid var(--border); 
            display: flex; flex-direction: column; 
            max-height: 90vh; transition: height 0.3s;
            box-shadow: 0 8px 40px rgba(0,0,0,0.8); 
            overflow: hidden;
        }
        
        .panel.collapsed { width: auto; max-height: 48px; }
        .panel.collapsed .panel-content { display: none; }
        .panel.collapsed .collapse-btn { transform: rotate(180deg); }

        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; cursor: pointer; background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border); user-select: none;
        }
        .panel-header:hover h2 { color: #fff; text-shadow: 0 0 8px var(--accent); }

        .collapse-btn {
            background: none; border: 1px solid #444; color: #888; width: 24px; height: 24px;
            border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center;
            justify-content: center; transition: all 0.2s; padding: 0;
        }
        .collapse-btn:hover { background: #333; color: #fff; border-color: #666; }

        .panel-content { padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }

        h2 { margin: 0; font-size: 14px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 800; }
        h3 { margin: 10px 0 5px 0; font-size: 11px; color: #888; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 4px; }
        
        button.action-btn { 
            background: #222; color: #fff; border: 1px solid #444; padding: 10px; border-radius: 4px; 
            cursor: pointer; transition: 0.2s; text-transform: uppercase; font-size: 11px; font-weight: bold; width: 100%; 
        }
        button.action-btn:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        button.action-btn.secondary { border-color: #555; }
        button.action-btn.secondary:hover { background: #444; color: #fff; border-color: #666; }
        button.delete-btn { background: #422; border-color: #633; }
        button.delete-btn:hover { background: #f44; color: #fff; }
        button.export-btn { background: #264; border-color: #3a6; }
        button.export-btn:hover { background: var(--accent); color: #000; }

        .system-list { display: flex; flex-direction: column; gap: 2px; max-height: 300px; overflow-y: auto; }
        .system-item { 
            padding: 8px 10px; background: rgba(255,255,255,0.05); border-radius: 4px; 
            cursor: pointer; display: flex; align-items: center; justify-content: space-between;
            border: 1px solid transparent; transition: all 0.1s; 
        }
        .system-item:hover { background: rgba(255,255,255,0.1); }
        .system-item.selected { border-color: var(--accent); background: rgba(0, 255, 136, 0.1); }
        .system-icon { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 6px currentColor; }
        .system-bodies { font-size: 10px; color: #666; }

        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; margin: 4px 0; }
        input[type=text], input[type=number] { 
            background: #1a1a1a; border: 1px solid #333; color: #fff; padding: 8px; 
            border-radius: 4px; width: 100%; box-sizing: border-box; 
        }
        select { width: 100%; background: #222; color: #fff; border: 1px solid #444; padding: 6px; border-radius: 4px; }
        .val { font-family: monospace; color: var(--accent); }
        
        input[type=file] { display: none; }

        /* Zoom indicator */
        #zoom-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 10px 20px; border-radius: 8px;
            border: 1px solid var(--border); pointer-events: auto;
            display: flex; align-items: center; gap: 15px; z-index: 10;
        }
        #zoom-indicator .zoom-btn {
            background: #333; border: 1px solid #555; color: #fff; width: 30px; height: 30px;
            border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;
        }
        #zoom-indicator .zoom-btn:hover { background: var(--accent); color: #000; }
        #zoom-level { font-family: monospace; color: var(--accent); min-width: 60px; text-align: center; }

        /* View mode toggle */
        .view-toggle { display: flex; gap: 4px; margin-bottom: 10px; }
        .view-toggle button { flex: 1; padding: 8px; font-size: 10px; }
        .view-toggle button.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* WELCOME SCREEN */
        #welcome {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 450px; text-align: center; color: #fff; pointer-events: none;
            background: rgba(0,0,0,0.9); padding: 40px; border-radius: 16px; border: 1px solid #333;
            box-shadow: 0 0 80px rgba(0,255,136,0.1); z-index: 5;
            transition: opacity 0.5s;
        }
        #welcome.hidden { opacity: 0; pointer-events: none; }
        #welcome h1 { margin: 0 0 10px 0; color: var(--accent); font-weight: 300; letter-spacing: 4px; text-transform: uppercase; }
        #welcome p { color: #888; line-height: 1.6; font-size: 14px; }
        .step { background: #1a1a1a; padding: 12px; margin: 10px 0; border-radius: 4px; border: 1px solid #333; display: flex; align-items: center; gap: 12px; text-align: left; }
        .step-num { background: var(--accent); color: #000; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }

        /* Galaxy Stats */
        #galaxy-stats {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 8px 20px; border-radius: 8px;
            border: 1px solid var(--border); pointer-events: none;
            font-family: monospace; color: #888; font-size: 11px; z-index: 10;
        }
        #galaxy-stats span { color: var(--accent); }

        /* Spiral arm selector */
        .arm-selector { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 5px; }
        .arm-btn { 
            padding: 6px; font-size: 10px; background: #222; border: 1px solid #444; 
            color: #888; border-radius: 4px; cursor: pointer; 
        }
        .arm-btn:hover { background: #333; color: #fff; }
        .arm-btn.active { background: var(--accent2); color: #000; border-color: var(--accent2); }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="welcome">
        <h1>üåå Galaxy Editor</h1>
        <p>Assemble your solar systems into a galaxy with spiral arms.</p>
        
        <div class="step">
            <div class="step-num">1</div>
            <div><strong>Import Solar Systems:</strong> Load <em>solarsystem_*.zip</em> files or build from individual body ZIPs.</div>
        </div>
        <div class="step">
            <div class="step-num">2</div>
            <div><strong>Position in Galaxy:</strong> Drag systems or assign them to spiral arms. Adjust distance from core.</div>
        </div>
        <div class="step">
            <div class="step-num">3</div>
            <div><strong>Zoom & Explore:</strong> Use scroll wheel to zoom from galaxy view down to system detail.</div>
        </div>
        <div class="step">
            <div class="step-num">4</div>
            <div><strong>Export Galaxy:</strong> Save your entire galaxy as a single file.</div>
        </div>
    </div>

    <div id="galaxy-stats">
        Systems: <span id="statSystems">0</span> | 
        Bodies: <span id="statBodies">0</span> | 
        Radius: <span id="statRadius">0</span> ly
    </div>

    <div id="ui-layer">
        <div class="panel" id="leftPanel">
            <div class="panel-header" onclick="togglePanel('leftPanel')">
                <h2>Galaxy</h2>
                <button class="collapse-btn">‚ñº</button>
            </div>
            <div class="panel-content">
                <h3>Import</h3>
                <button id="btnImportSystem" class="action-btn">üì¶ Import Solar System</button>
                <button id="btnImportBodies" class="action-btn secondary">‚≠ê Import Bodies (Build System)</button>
                <input type="file" id="fileInputSystem" accept=".zip" multiple>
                <input type="file" id="fileInputBodies" accept=".zip" multiple>
                
                <h3>Solar Systems</h3>
                <div id="systemList" class="system-list">
                    <div style="color:#666; text-align:center; padding: 20px; font-size: 12px;">
                        No systems imported yet
                    </div>
                </div>

                <h3>Galaxy Tools</h3>
                <div class="control-row"><label>Galaxy Name</label></div>
                <input type="text" id="galaxyName" value="Andromeda" placeholder="Galaxy Name">
                
                <div class="control-row" style="margin-top: 10px;"><label>Spiral Arms</label><span id="armCountVal" class="val">4</span></div>
                <input type="range" id="armCount" min="2" max="8" step="1" value="4">
                
                <div class="control-row"><label>Arm Tightness</label><span id="armTightnessVal" class="val">0.50</span></div>
                <input type="range" id="armTightness" min="0.1" max="1.5" step="0.05" value="0.5">

                <h3>Export</h3>
                <button id="btnExportGalaxy" class="action-btn export-btn">üíæ Export Galaxy</button>
            </div>
        </div>

        <div class="panel" id="detailPanel" style="display:none;">
            <div class="panel-header" onclick="togglePanel('detailPanel')">
                <h2 id="detailName">System Details</h2>
                <button class="collapse-btn">‚ñº</button>
            </div>
            
            <div class="panel-content">
                <h3>System Name</h3>
                <input type="text" id="systemName" placeholder="System Name">

                <h3>Galactic Position</h3>
                <div class="control-row"><label>Distance from Core</label><span id="distCoreVal" class="val">0</span> ly</div>
                <input type="range" id="distCore" min="0" max="500" step="1">
                
                <div class="control-row"><label>Angle</label><span id="angleVal" class="val">0</span>¬∞</div>
                <input type="range" id="angle" min="0" max="360" step="1">

                <h3>Spiral Arm</h3>
                <div class="arm-selector" id="armSelector"></div>

                <h3>Bodies in System</h3>
                <div id="bodyList" class="system-list" style="max-height: 150px;"></div>

                <button class="action-btn delete-btn" id="btnDeleteSystem" style="margin-top: 15px;">üóëÔ∏è Remove System</button>
            </div>
        </div>
    </div>

    <div id="zoom-indicator">
        <button class="zoom-btn" id="btnZoomOut">‚àí</button>
        <span id="zoom-level">100%</span>
        <button class="zoom-btn" id="btnZoomIn">+</button>
        <span style="color:#666; margin-left: 10px;">|</span>
        <button class="zoom-btn" id="btnResetView" style="width: auto; padding: 0 10px; font-size: 11px;">‚åÇ</button>
    </div>

    <script>
        function togglePanel(id) {
            const panel = document.getElementById(id);
            panel.classList.toggle('collapsed');
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GLOBAL SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020208);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 400, 300);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 2000;
        controls.minDistance = 5;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.5, 0.3);
        composer.addPass(bloomPass);

        // --- GALAXY CORE ---
        const coreGeo = new THREE.SphereGeometry(8, 32, 32);
        const coreMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffcc, 
            transparent: true, 
            opacity: 0.9 
        });
        const galaxyCore = new THREE.Mesh(coreGeo, coreMat);
        scene.add(galaxyCore);

        // Core glow
        const glowGeo = new THREE.SphereGeometry(15, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({ 
            color: 0xffcc66, 
            transparent: true, 
            opacity: 0.3 
        });
        scene.add(new THREE.Mesh(glowGeo, glowMat));

        // --- BACKGROUND STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(20000 * 3);
        for(let i = 0; i < 20000 * 3; i++) starPos[i] = (Math.random() - 0.5) * 4000;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.4 })));

        // --- SPIRAL ARM DUST ---
        let spiralParticles = null;
        let spiralArmCount = 4;
        let spiralTightness = 0.5;

        function generateSpiralDust() {
            if (spiralParticles) scene.remove(spiralParticles);

            const count = 50000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const arm = Math.floor(Math.random() * spiralArmCount);
                const armAngle = (arm / spiralArmCount) * Math.PI * 2;
                
                const dist = Math.pow(Math.random(), 0.5) * 400;
                const spiralAngle = armAngle + dist * spiralTightness * 0.02;
                const spread = (Math.random() - 0.5) * (30 + dist * 0.15);
                
                positions[i * 3] = Math.cos(spiralAngle) * dist + (Math.random() - 0.5) * spread;
                positions[i * 3 + 1] = (Math.random() - 0.5) * (5 + dist * 0.02);
                positions[i * 3 + 2] = Math.sin(spiralAngle) * dist + (Math.random() - 0.5) * spread;
                
                // Color gradient: blue-white core to reddish outer
                const t = dist / 400;
                colors[i * 3] = 0.7 + t * 0.3;
                colors[i * 3 + 1] = 0.7 - t * 0.4;
                colors[i * 3 + 2] = 1.0 - t * 0.5;
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const mat = new THREE.PointsMaterial({ 
                size: 0.8, 
                transparent: true, 
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            spiralParticles = new THREE.Points(geo, mat);
            scene.add(spiralParticles);
        }
        generateSpiralDust();

        // --- SHADER FOR CELESTIAL BODIES ---
        const shaderUtils = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
            float fbm(vec3 p, int octaves, float persistence, float lacunarity) {
                float total = 0.0; float amplitude = 1.0; float frequency = 1.0; float maxValue = 0.0;
                for(int i=0; i<20; i++) {
                    if (i >= octaves) break;
                    total += snoise(p * frequency) * amplitude;
                    maxValue += amplitude; amplitude *= persistence; frequency *= lacunarity;
                }
                return total / maxValue;
            }
        `;

        const bodyVertexShader = `
            uniform float radius;
            uniform float heightScale;
            uniform float frequency;
            uniform int octaves;
            uniform float persistence;
            uniform float ridge;
            uniform float warpScale;
            uniform vec3 seedOffset;
            uniform float shapeFactor;
            uniform float isSun;
            uniform float time;

            varying vec3 vPos;
            varying float vElevation;
            varying float vSunNoise;

            ${shaderUtils}

            void main() {
                vec3 sphereP = normalize(position);
                vec3 absP = abs(position);
                float maxC = max(max(absP.x, absP.y), absP.z);
                vec3 boxP = position / maxC;
                vec3 baseDir = mix(sphereP, boxP, shapeFactor);
                vec3 basePos = baseDir * radius;

                vec3 warpPos = sphereP * 0.5 + seedOffset;
                if (isSun > 0.5) warpPos += vec3(time * 0.1);

                float warp = snoise(warpPos) * warpScale;
                vec3 noisePos = (sphereP + vec3(warp)) * frequency + seedOffset;
                if (isSun > 0.5) noisePos += vec3(time * 0.2, -time*0.1, time*0.1);

                float n = fbm(noisePos, octaves, persistence, 2.0);
                float r = 1.0 - abs(snoise(noisePos));
                r = pow(r, 3.0);
                float finalNoise = mix(n, r, ridge);

                float displacement = finalNoise * heightScale;
                vec3 finalPos = basePos + normalize(baseDir) * displacement;

                vPos = finalPos;
                vElevation = finalNoise;
                vSunNoise = finalNoise;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }
        `;

        const bodyFragmentShader = `
            uniform float oceanLevel;
            uniform float snowLevel;
            uniform float time;
            uniform float isSun;
            uniform vec3 oceanColor;
            uniform vec3 beachColor;
            uniform vec3 grassColor;
            uniform vec3 rockColor;
            uniform vec3 snowColor;

            varying vec3 vPos;
            varying float vElevation;
            varying float vSunNoise;

            ${shaderUtils}

            void main() {
                if (isSun > 0.5) {
                    float heat = vSunNoise * 0.5 + 0.5;
                    float detail = snoise(vPos * 5.0 + vec3(time)) * 0.1;
                    heat += detail;
                    vec3 hot = vec3(1.0, 1.0, 0.8);
                    vec3 cool = vec3(1.0, 0.4, 0.1);
                    vec3 sunColor = mix(cool, hot, heat);
                    gl_FragColor = vec4(sunColor, 1.0);
                    return;
                }

                float e = vElevation;
                vec3 color;
                
                if (e < oceanLevel) {
                    color = oceanColor;
                } else if (e < oceanLevel + 0.05) {
                    color = beachColor;
                } else if (e < snowLevel - 0.1) {
                    float t = (e - oceanLevel - 0.05) / (snowLevel - 0.1 - oceanLevel - 0.05);
                    color = mix(grassColor, rockColor, t);
                } else {
                    color = snowColor;
                }

                // Simple lighting
                vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
                vec3 normal = normalize(vPos);
                float diff = max(dot(normal, lightDir), 0.3);
                
                gl_FragColor = vec4(color * diff, 1.0);
            }
        `;

        // --- HASH FUNCTIONS ---
        function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return [(h1^h2^h3^h4)>>>0];
        }
        
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        // --- CELESTIAL BODY CLASS (for detail view) ---
        class CelestialBody {
            constructor(data, texture) {
                this.data = data;
                this.type = data.type || 'planet';
                
                const p = data.params;
                const c = data.colors;
                const seedHash = cyrb128(data.seed);
                const rng = mulberry32(seedHash[0]);
                const seedOffset = new THREE.Vector3(rng()*100, rng()*100, rng()*100);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        seedOffset: { value: seedOffset },
                        radius: { value: 1.0 },
                        heightScale: { value: parseFloat(p.heightScale) },
                        frequency: { value: parseFloat(p.frequency) },
                        octaves: { value: parseInt(p.octaves) },
                        persistence: { value: parseFloat(p.persistence) },
                        ridge: { value: parseFloat(p.ridge) },
                        warpScale: { value: parseFloat(p.warpScale) },
                        shapeFactor: { value: data.mode === 'cube' ? 0.7 : 0.0 },
                        oceanLevel: { value: parseFloat(p.oceanLevel) },
                        snowLevel: { value: parseFloat(p.snowLevel) },
                        time: { value: 0 },
                        oceanColor: { value: new THREE.Color(c.ocean) },
                        beachColor: { value: new THREE.Color(c.beach) },
                        grassColor: { value: new THREE.Color(c.grass) },
                        rockColor: { value: new THREE.Color(c.rock) },
                        snowColor: { value: new THREE.Color(c.snow) },
                        isSun: { value: this.type === 'sun' ? 1.0 : 0.0 }
                    },
                    vertexShader: bodyVertexShader,
                    fragmentShader: bodyFragmentShader
                });

                const geo = new THREE.BoxGeometry(1, 1, 1, 64, 64, 64);
                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.scale.setScalar(parseFloat(p.radius));
            }
        }

        // --- SOLAR SYSTEM CLASS ---
        class SolarSystem {
            constructor(id, name = 'Unknown System') {
                this.id = id;
                this.name = name;
                this.bodies = []; // Array of body data
                this.bodyTextures = new Map(); // Map of body seed -> texture
                
                // Galactic position (polar coordinates)
                this.distanceFromCore = 100 + Math.random() * 200;
                this.angle = Math.random() * Math.PI * 2;
                this.spiralArm = -1; // -1 = free position
                
                // 3D representation
                this.group = new THREE.Group();
                
                // System marker (visible from galaxy view)
                const markerGeo = new THREE.SphereGeometry(2, 16, 16);
                this.markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffcc00, 
                    transparent: true, 
                    opacity: 0.9 
                });
                this.marker = new THREE.Mesh(markerGeo, this.markerMaterial);
                this.group.add(this.marker);
                
                // Selection ring
                const ringGeo = new THREE.RingGeometry(3, 3.5, 32);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0 
                });
                this.selectionRing = new THREE.Mesh(ringGeo, ringMat);
                this.selectionRing.rotation.x = Math.PI / 2;
                this.group.add(this.selectionRing);
                
                // Label sprite
                this.labelSprite = this.createLabel(name);
                this.labelSprite.position.y = 5;
                this.group.add(this.labelSprite);
                
                this.updatePosition();
                scene.add(this.group);
            }
            
            createLabel(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, 256, 64);
                ctx.font = 'bold 24px Segoe UI';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText(text, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true,
                    opacity: 0.8
                });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(20, 5, 1);
                return sprite;
            }
            
            updateLabel() {
                this.group.remove(this.labelSprite);
                this.labelSprite.material.dispose();
                this.labelSprite = this.createLabel(this.name);
                this.labelSprite.position.y = 5;
                this.group.add(this.labelSprite);
            }
            
            addBody(data, texture = null) {
                this.bodies.push(data);
                if (texture) {
                    this.bodyTextures.set(data.seed, texture);
                }
                
                // Update marker color based on sun color if present
                const sun = this.bodies.find(b => b.type === 'sun');
                if (sun) {
                    this.markerMaterial.color.set(sun.colors.ocean);
                    this.name = sun.seed + ' System';
                    this.updateLabel();
                }
            }
            
            updatePosition() {
                let x, z;
                
                if (this.spiralArm >= 0) {
                    // Snap to spiral arm
                    const armAngle = (this.spiralArm / spiralArmCount) * Math.PI * 2;
                    const spiralAngle = armAngle + this.distanceFromCore * spiralTightness * 0.02;
                    x = Math.cos(spiralAngle) * this.distanceFromCore;
                    z = Math.sin(spiralAngle) * this.distanceFromCore;
                } else {
                    // Free position
                    x = Math.cos(this.angle) * this.distanceFromCore;
                    z = Math.sin(this.angle) * this.distanceFromCore;
                }
                
                this.group.position.set(x, 0, z);
            }
            
            setSelected(selected) {
                this.selectionRing.material.opacity = selected ? 0.8 : 0;
                this.marker.scale.setScalar(selected ? 1.3 : 1);
            }
            
            getExportData() {
                return {
                    name: this.name,
                    distanceFromCore: this.distanceFromCore,
                    angle: this.angle,
                    spiralArm: this.spiralArm,
                    bodies: this.bodies
                };
            }
            
            dispose() {
                scene.remove(this.group);
                this.marker.geometry.dispose();
                this.markerMaterial.dispose();
                this.selectionRing.geometry.dispose();
                this.selectionRing.material.dispose();
                this.labelSprite.material.dispose();
            }
        }

        // --- APP STATE ---
        const solarSystems = [];
        let selectedSystem = null;
        let systemCounter = 0;
        let pendingBodies = []; // Bodies waiting to be assembled into a system

        // --- UI HELPERS ---
        const $ = (id) => document.getElementById(id);
        const welcomeEl = $('welcome');

        // --- IMPORT HANDLERS ---
        $('btnImportSystem').onclick = () => $('fileInputSystem').click();
        $('btnImportBodies').onclick = () => $('fileInputBodies').click();

        // Import a complete solar system ZIP
        $('fileInputSystem').onchange = async (e) => {
            const files = Array.from(e.target.files);
            for (const file of files) {
                await importSolarSystemZip(file);
            }
            $('fileInputSystem').value = '';
        };

        // Import individual body ZIPs to build a system
        $('fileInputBodies').onchange = async (e) => {
            const files = Array.from(e.target.files);
            
            if (files.length === 0) return;
            
            // Create a new system from these bodies
            const system = new SolarSystem(systemCounter++, 'New System');
            
            for (const file of files) {
                try {
                    const zip = await JSZip.loadAsync(file);
                    const jsonStr = await zip.file("planet_data.json").async("string");
                    const data = JSON.parse(jsonStr);
                    
                    let texture = null;
                    const imgFile = zip.file("heightmap.png");
                    if (imgFile) {
                        const b64 = await imgFile.async("base64");
                        texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                    }
                    
                    system.addBody(data, texture);
                } catch (err) {
                    console.error("Error loading body:", err);
                }
            }
            
            solarSystems.push(system);
            updateUI();
            selectSystem(system);
            
            $('fileInputBodies').value = '';
        };

        async function importSolarSystemZip(file) {
            try {
                const zip = await JSZip.loadAsync(file);
                
                // Check if this is a galaxy file or solar system file
                const galaxyFile = zip.file("galaxy_data.json");
                if (galaxyFile) {
                    // It's a galaxy file - import all systems
                    await importGalaxyZip(zip);
                    return;
                }
                
                // Check for solar system manifest
                const manifestFile = zip.file("system_data.json");
                if (manifestFile) {
                    const manifestStr = await manifestFile.async("string");
                    const manifest = JSON.parse(manifestStr);
                    
                    const system = new SolarSystem(systemCounter++, manifest.name || 'Imported System');
                    system.distanceFromCore = manifest.distanceFromCore || 100;
                    system.angle = manifest.angle || 0;
                    system.spiralArm = manifest.spiralArm ?? -1;
                    
                    // Load each body
                    for (const bodyInfo of manifest.bodies) {
                        const bodyFile = zip.file(bodyInfo.file);
                        if (bodyFile) {
                            const bodyZip = await JSZip.loadAsync(await bodyFile.async("blob"));
                            const bodyJsonStr = await bodyZip.file("planet_data.json").async("string");
                            const bodyData = JSON.parse(bodyJsonStr);
                            
                            let texture = null;
                            const imgFile = bodyZip.file("heightmap.png");
                            if (imgFile) {
                                const b64 = await imgFile.async("base64");
                                texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                            }
                            
                            system.addBody(bodyData, texture);
                        }
                    }
                    
                    system.updatePosition();
                    solarSystems.push(system);
                } else {
                    // Try to load as individual body ZIP (create single-body system)
                    const jsonFile = zip.file("planet_data.json");
                    if (jsonFile) {
                        const jsonStr = await jsonFile.async("string");
                        const data = JSON.parse(jsonStr);
                        
                        const system = new SolarSystem(systemCounter++, data.seed + ' System');
                        
                        let texture = null;
                        const imgFile = zip.file("heightmap.png");
                        if (imgFile) {
                            const b64 = await imgFile.async("base64");
                            texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                        }
                        
                        system.addBody(data, texture);
                        solarSystems.push(system);
                    }
                }
                
                updateUI();
            } catch (err) {
                console.error("Error importing solar system:", err);
                alert("Error importing file: " + err.message);
            }
        }

        async function importGalaxyZip(zip) {
            const galaxyStr = await zip.file("galaxy_data.json").async("string");
            const galaxyData = JSON.parse(galaxyStr);
            
            $('galaxyName').value = galaxyData.name || 'Imported Galaxy';
            $('armCount').value = galaxyData.spiralArmCount || 4;
            $('armTightness').value = galaxyData.spiralTightness || 0.5;
            spiralArmCount = galaxyData.spiralArmCount || 4;
            spiralTightness = galaxyData.spiralTightness || 0.5;
            updateArmControls();
            generateSpiralDust();
            
            for (const sysData of galaxyData.systems) {
                const system = new SolarSystem(systemCounter++, sysData.name);
                system.distanceFromCore = sysData.distanceFromCore;
                system.angle = sysData.angle;
                system.spiralArm = sysData.spiralArm;
                
                for (const bodyData of sysData.bodies) {
                    system.addBody(bodyData);
                }
                
                system.updatePosition();
                solarSystems.push(system);
            }
            
            updateUI();
        }

        // --- SYSTEM SELECTION ---
        function selectSystem(system) {
            if (selectedSystem) {
                selectedSystem.setSelected(false);
            }
            
            selectedSystem = system;
            
            if (system) {
                system.setSelected(true);
                $('detailPanel').style.display = 'flex';
                $('detailName').textContent = system.name;
                $('systemName').value = system.name;
                $('distCore').value = system.distanceFromCore;
                $('distCoreVal').textContent = Math.round(system.distanceFromCore);
                $('angle').value = (system.angle * 180 / Math.PI) % 360;
                $('angleVal').textContent = Math.round((system.angle * 180 / Math.PI) % 360);
                
                updateArmSelector(system);
                updateBodyList(system);
            } else {
                $('detailPanel').style.display = 'none';
            }
            
            renderSystemList();
        }

        function updateArmSelector(system) {
            const selector = $('armSelector');
            selector.innerHTML = '';
            
            // Free position button
            const freeBtn = document.createElement('button');
            freeBtn.className = 'arm-btn' + (system.spiralArm === -1 ? ' active' : '');
            freeBtn.textContent = 'Free';
            freeBtn.onclick = () => {
                system.spiralArm = -1;
                system.updatePosition();
                updateArmSelector(system);
            };
            selector.appendChild(freeBtn);
            
            // Arm buttons
            for (let i = 0; i < spiralArmCount; i++) {
                const btn = document.createElement('button');
                btn.className = 'arm-btn' + (system.spiralArm === i ? ' active' : '');
                btn.textContent = `Arm ${i + 1}`;
                btn.onclick = () => {
                    system.spiralArm = i;
                    system.updatePosition();
                    updateArmSelector(system);
                };
                selector.appendChild(btn);
            }
        }

        function updateBodyList(system) {
            const list = $('bodyList');
            list.innerHTML = '';
            
            if (system.bodies.length === 0) {
                list.innerHTML = '<div style="color:#666; text-align:center; padding: 10px; font-size: 11px;">No bodies</div>';
                return;
            }
            
            for (const body of system.bodies) {
                const div = document.createElement('div');
                div.className = 'system-item';
                div.style.cursor = 'default';
                
                const icon = body.type === 'sun' ? '‚òÄÔ∏è' : body.type === 'moon' ? 'üåô' : 'ü™ê';
                div.innerHTML = `
                    <span>${icon} ${body.seed}</span>
                    <span style="font-size:10px; color:#666;">${body.type}</span>
                `;
                list.appendChild(div);
            }
        }

        // --- UI RENDERING ---
        function renderSystemList() {
            const list = $('systemList');
            
            if (solarSystems.length === 0) {
                list.innerHTML = '<div style="color:#666; text-align:center; padding: 20px; font-size: 12px;">No systems imported yet</div>';
                welcomeEl.classList.remove('hidden');
                return;
            }
            
            welcomeEl.classList.add('hidden');
            list.innerHTML = '';
            
            for (const system of solarSystems) {
                const div = document.createElement('div');
                div.className = 'system-item' + (selectedSystem === system ? ' selected' : '');
                
                const sun = system.bodies.find(b => b.type === 'sun');
                const color = sun ? sun.colors.ocean : '#ffcc00';
                
                div.innerHTML = `
                    <div style="display:flex; align-items:center;">
                        <span class="system-icon" style="background:${color}; color:${color}"></span>
                        <span>${system.name}</span>
                    </div>
                    <span class="system-bodies">${system.bodies.length} bodies</span>
                `;
                
                div.onclick = () => selectSystem(system);
                list.appendChild(div);
            }
        }

        function updateUI() {
            renderSystemList();
            updateStats();
        }

        function updateStats() {
            $('statSystems').textContent = solarSystems.length;
            $('statBodies').textContent = solarSystems.reduce((sum, s) => sum + s.bodies.length, 0);
            const maxDist = solarSystems.reduce((max, s) => Math.max(max, s.distanceFromCore), 0);
            $('statRadius').textContent = Math.round(maxDist);
        }

        function updateArmControls() {
            $('armCountVal').textContent = spiralArmCount;
            $('armTightnessVal').textContent = spiralTightness.toFixed(2);
        }

        // --- CONTROL HANDLERS ---
        $('distCore').oninput = (e) => {
            if (!selectedSystem) return;
            selectedSystem.distanceFromCore = parseFloat(e.target.value);
            $('distCoreVal').textContent = Math.round(selectedSystem.distanceFromCore);
            selectedSystem.updatePosition();
            updateStats();
        };

        $('angle').oninput = (e) => {
            if (!selectedSystem) return;
            selectedSystem.angle = parseFloat(e.target.value) * Math.PI / 180;
            $('angleVal').textContent = Math.round(parseFloat(e.target.value));
            selectedSystem.updatePosition();
        };

        $('systemName').oninput = (e) => {
            if (!selectedSystem) return;
            selectedSystem.name = e.target.value;
            selectedSystem.updateLabel();
            $('detailName').textContent = e.target.value;
            renderSystemList();
        };

        $('armCount').oninput = (e) => {
            spiralArmCount = parseInt(e.target.value);
            $('armCountVal').textContent = spiralArmCount;
            generateSpiralDust();
            solarSystems.forEach(s => s.updatePosition());
            if (selectedSystem) updateArmSelector(selectedSystem);
        };

        $('armTightness').oninput = (e) => {
            spiralTightness = parseFloat(e.target.value);
            $('armTightnessVal').textContent = spiralTightness.toFixed(2);
            generateSpiralDust();
            solarSystems.forEach(s => s.updatePosition());
        };

        $('btnDeleteSystem').onclick = () => {
            if (!selectedSystem) return;
            
            const idx = solarSystems.indexOf(selectedSystem);
            if (idx > -1) {
                selectedSystem.dispose();
                solarSystems.splice(idx, 1);
            }
            
            selectedSystem = null;
            $('detailPanel').style.display = 'none';
            updateUI();
        };

        // --- EXPORT ---
        $('btnExportGalaxy').onclick = async () => {
            const zip = new JSZip();
            
            const galaxyData = {
                name: $('galaxyName').value,
                spiralArmCount: spiralArmCount,
                spiralTightness: spiralTightness,
                systems: solarSystems.map(s => s.getExportData())
            };
            
            zip.file("galaxy_data.json", JSON.stringify(galaxyData, null, 2));
            
            const blob = await zip.generateAsync({ type: "blob" });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `galaxy_${$('galaxyName').value.replace(/\s+/g, '_')}.zip`;
            link.click();
        };

        // --- ZOOM CONTROLS ---
        function updateZoomDisplay() {
            const dist = camera.position.length();
            const percent = Math.round((1000 / dist) * 100);
            $('zoom-level').textContent = Math.min(percent, 9999) + '%';
        }

        $('btnZoomIn').onclick = () => {
            camera.position.multiplyScalar(0.7);
            controls.update();
            updateZoomDisplay();
        };

        $('btnZoomOut').onclick = () => {
            camera.position.multiplyScalar(1.4);
            controls.update();
            updateZoomDisplay();
        };

        $('btnResetView').onclick = () => {
            camera.position.set(0, 400, 300);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
            updateZoomDisplay();
        };

        controls.addEventListener('change', updateZoomDisplay);

        // --- RAYCASTING FOR SELECTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (e) => {
            // Ignore if clicking on UI
            if (e.target !== renderer.domElement) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const markers = solarSystems.map(s => s.marker);
            const intersects = raycaster.intersectObjects(markers);
            
            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object;
                const clickedSystem = solarSystems.find(s => s.marker === clickedMarker);
                if (clickedSystem) {
                    selectSystem(clickedSystem);
                }
            }
        });

        // Double-click to focus on system
        renderer.domElement.addEventListener('dblclick', (e) => {
            if (e.target !== renderer.domElement) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const markers = solarSystems.map(s => s.marker);
            const intersects = raycaster.intersectObjects(markers);
            
            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object;
                const clickedSystem = solarSystems.find(s => s.marker === clickedMarker);
                if (clickedSystem) {
                    // Animate camera to focus on system
                    const pos = clickedSystem.group.position.clone();
                    controls.target.copy(pos);
                    camera.position.set(pos.x, pos.y + 30, pos.z + 50);
                    updateZoomDisplay();
                }
            }
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Rotate galaxy core glow
            galaxyCore.rotation.y += dt * 0.1;
            
            // Subtle spiral rotation
            if (spiralParticles) {
                spiralParticles.rotation.y += dt * 0.002;
            }
            
            // Pulse selected system
            if (selectedSystem) {
                const pulse = 0.8 + Math.sin(time * 4) * 0.2;
                selectedSystem.selectionRing.material.opacity = pulse;
            }
            
            controls.update();
            composer.render();
        }
        
        animate();
        updateZoomDisplay();

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
