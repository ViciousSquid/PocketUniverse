<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solar System Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root { --accent: #00ff88; --panel: rgba(10, 10, 12, 0.95); --border: rgba(255,255,255,0.1); }
        body { margin: 0; overflow: hidden; background: #000; color: #e0e0e0; font-family: 'Segoe UI', Roboto, sans-serif; font-size: 13px; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        .panel { 
            pointer-events: auto; background: var(--panel); backdrop-filter: blur(12px); 
            width: 300px; padding: 0; border-radius: 8px; border: 1px solid var(--border); 
            display: flex; flex-direction: column; 
            max-height: 90vh; transition: height 0.3s;
            box-shadow: 0 8px 40px rgba(0,0,0,0.8); 
            overflow: hidden; /* Important for collapse animation */
        }
        
        /* Collapsed State */
        .panel.collapsed { width: auto; max-height: 48px; }
        .panel.collapsed .panel-content { display: none; }
        .panel.collapsed .collapse-btn { transform: rotate(180deg); }

        /* Header Styling */
        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; cursor: pointer; background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border); user-select: none;
        }
        .panel-header:hover h2 { color: #fff; text-shadow: 0 0 8px var(--accent); }

        .collapse-btn {
            background: none; border: 1px solid #444; color: #888; width: 24px; height: 24px;
            border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center;
            justify-content: center; transition: all 0.2s; padding: 0;
        }
        .collapse-btn:hover { background: #333; color: #fff; border-color: #666; }

        .panel-content { padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }

        h2 { margin: 0; font-size: 14px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 800; }
        h3 { margin: 10px 0 5px 0; font-size: 11px; color: #888; text-transform: uppercase; }
        
        /* General Controls */
        button.action-btn { background: #222; color: #fff; border: 1px solid #444; padding: 10px; border-radius: 4px; cursor: pointer; transition: 0.2s; text-transform: uppercase; font-size: 11px; font-weight: bold; width: 100%; }
        button.action-btn:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        button.delete-btn { background: #422; border-color: #633; margin-top: 5px; }
        button.delete-btn:hover { background: #f44; color: #fff; }

        /* Hierarchy List Styling */
        .body-list { display: flex; flex-direction: column; gap: 2px; }
        .body-item { padding: 6px 8px; background: rgba(255,255,255,0.05); border-radius: 4px; cursor: pointer; display: flex; align-items: center; border: 1px solid transparent; transition: all 0.1s; }
        .body-item:hover { background: rgba(255,255,255,0.1); }
        .body-item.selected { border-color: var(--accent); background: rgba(0, 255, 136, 0.1); }
        .body-icon { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 4px currentColor; }
        
        .indent-0 { margin-left: 0px; border-left: 2px solid #444; }
        .indent-1 { margin-left: 20px; border-left: 2px solid #666; }
        .indent-2 { margin-left: 40px; border-left: 2px solid #888; }

        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; margin: 4px 0; }
        select { width: 100%; background: #222; color: #fff; border: 1px solid #444; padding: 6px; border-radius: 4px; margin-top: 4px; }
        .val { font-family: monospace; color: var(--accent); }
        
        #fileInput { display: none; }

        /* Zoom indicator */
        #zoom-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 10px 20px; border-radius: 8px;
            border: 1px solid var(--border); pointer-events: auto;
            display: flex; align-items: center; gap: 15px; z-index: 10;
        }
        #zoom-indicator .zoom-btn {
            background: #333; border: 1px solid #555; color: #fff; width: 30px; height: 30px;
            border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;
        }
        #zoom-indicator .zoom-btn:hover { background: var(--accent); color: #000; }
        #zoom-level { font-family: monospace; color: var(--accent); min-width: 60px; text-align: center; }

        /* Body selection label */
        #body-label {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: var(--panel); padding: 12px 24px; border-radius: 8px;
            border: 1px solid var(--accent); pointer-events: none;
            font-family: 'Segoe UI', sans-serif; font-size: 14px; z-index: 15;
            display: none; text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        #body-label .body-name { color: #fff; font-size: 18px; font-weight: bold; margin-bottom: 4px; }
        #body-label .body-type { color: var(--accent); font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        #body-label .body-hint { color: #666; font-size: 10px; margin-top: 6px; }

        /* WELCOME SCREEN */
        #welcome {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; text-align: center; color: #fff; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 40px; border-radius: 16px; border: 1px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 5;
            transition: opacity 0.5s;
        }
        #welcome.hidden { opacity: 0; pointer-events: none; }
        #welcome h1 { margin: 0 0 10px 0; color: var(--accent); font-weight: 300; letter-spacing: 4px; text-transform: uppercase; }
        #welcome p { color: #888; line-height: 1.6; font-size: 14px; }
        .step { background: #222; padding: 10px; margin: 10px 0; border-radius: 4px; border: 1px solid #333; display: flex; align-items: center; gap: 10px; text-align: left; }
        .step-num { background: var(--accent); color: #000; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="welcome">
        <h1>System Editor</h1>
        <p>Assemble your generated planets into a complete solar system.</p>
        
        <div class="step">
            <div class="step-num">1</div>
            <div><strong>Import Sun:</strong> Start by importing your <em>sun_*.zip</em> file to act as the center.</div>
        </div>
        <div class="step">
            <div class="step-num">2</div>
            <div><strong>Add Planets:</strong> Import <em>planet_*.zip</em> files. They will automatically orbit the sun.</div>
        </div>
        <div class="step">
            <div class="step-num">3</div>
            <div><strong>Add Moons:</strong> Import <em>moon_*.zip</em> files. They will attach to the last planet added.</div>
        </div>
        <p style="margin-top:20px; font-size: 12px; color: #666;">Use the <strong>hierarchy panel</strong> on the left to reorganize orbits.</p>
    </div>

    <div id="ui-layer">
        <div class="panel" id="leftPanel">
            <div class="panel-header" onclick="togglePanel('leftPanel')">
                <h2>Hierarchy</h2>
                <button class="collapse-btn">â–¼</button>
            </div>
            <div class="panel-content">
                <!-- Embedded Mode: Receive from Planet Editor -->
                <button id="btnReceivePlanets" class="action-btn" style="display:none; background: linear-gradient(135deg, #ff6600, #ff8833); color: #000; border: none; font-weight: bold;">
                    ðŸ“¥ Import from Planet Editor <span id="stagedCount" style="background:#000;color:#ff6600;padding:2px 6px;border-radius:10px;margin-left:5px;font-size:10px;">0</span>
                </button>
                
                <button id="btnImport" class="action-btn">âž• Import Body (ZIP)</button>
                <button id="btnRandomSystem" class="action-btn" style="background: #442; border-color: #664; margin-top: 5px;">ðŸŽ² Generate Random System</button>
                <button id="btnExportSystem" class="action-btn" style="background: #264; border-color: #3a6; margin-top: 5px;">ðŸ’¾ Export Solar System</button>
                
                <!-- Embedded Mode: Send to Galaxy Editor -->
                <button id="btnSendToGalaxy" class="action-btn" style="display:none; margin-top:8px; background:linear-gradient(135deg, #9933ff, #cc66ff); color:#fff; border:none; font-weight:bold;">
                    ðŸ“¤ Send to Galaxy Editor
                </button>
                
                <input type="file" id="fileInput" accept=".zip">
                <div id="bodyList" class="body-list">
                    </div>
            </div>
        </div>

        <div class="panel" id="detailPanel" style="display:none;">
            <div class="panel-header" onclick="togglePanel('detailPanel')">
                <h2 id="detailName">Details</h2>
                <button class="collapse-btn">â–¼</button>
            </div>
            
            <div class="panel-content">
                <h3>Hierarchy</h3>
                <div style="margin-bottom: 10px;">
                    <label style="color:#bbb;">Orbiting Parent</label>
                    <select id="parentSelect"></select>
                </div>

                <h3>Orbital Mechanics</h3>
                <div class="control-row"><label>Distance</label><span id="distVal" class="val">0</span></div>
                <input type="range" id="orbitDist" min="0" max="150" step="0.5">
                
                <div class="control-row"><label>Orbit Speed</label><span id="speedVal" class="val">0</span></div>
                <input type="range" id="orbitSpeed" min="0" max="3.0" step="0.01">

                <button class="action-btn delete-btn" id="btnDelete">Remove Object</button>
            </div>
        </div>
    </div>

    <div id="zoom-indicator">
        <button class="zoom-btn" id="btnZoomOut">âˆ’</button>
        <span id="zoom-level">100%</span>
        <button class="zoom-btn" id="btnZoomIn">+</button>
        <span style="color:#666; margin-left: 10px;">|</span>
        <button class="zoom-btn" id="btnResetView" style="width: auto; padding: 0 10px; font-size: 11px;">âŒ‚</button>
    </div>

    <div id="body-label">
        <div class="body-name" id="bodyLabelName">Planet Name</div>
        <div class="body-type" id="bodyLabelType">Planet</div>
        <div class="body-hint">Press ESC to return</div>
    </div>

    <script>
        function togglePanel(id) {
            const panel = document.getElementById(id);
            panel.classList.toggle('collapsed');
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GLOBAL SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 40, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // Starfield
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(5000 * 3);
        for(let i=0; i<5000*3; i++) starPos[i] = (Math.random() - 0.5) * 1000;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.3, transparent: true, opacity: 0.6})));

        // Lights
        const sunLight = new THREE.PointLight(0xffffff, 2, 500);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        // --- SHADER UTILS ---
        const shaderUtils = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
            float fbm(vec3 p, int octaves, float persistence, float lacunarity) {
                float total = 0.0; float amplitude = 1.0; float frequency = 1.0; float maxValue = 0.0;
                for(int i=0; i<20; i++) {
                    if (i >= octaves) break;
                    total += snoise(p * frequency) * amplitude;
                    maxValue += amplitude; amplitude *= persistence; frequency *= lacunarity;
                }
                return total / maxValue;
            }
            vec2 getUV(vec3 p) {
                vec3 n = normalize(p);
                float u = 0.5 + (atan(n.z, n.x) / (2.0 * 3.14159));
                float v = 0.5 - (asin(n.y) / 3.14159);
                return vec2(u, v);
            }
        `;

        const vertexShader = `
            uniform float radius;
            uniform float heightScale;
            uniform float frequency;
            uniform int octaves;
            uniform float persistence;
            uniform float ridge;
            uniform float warpScale;
            uniform vec3 seedOffset;
            uniform float shapeFactor; 
            uniform sampler2D heightMap;
            uniform float texMix;
            uniform float isSun;
            uniform float time;

            varying vec3 vPos;
            varying float vElevation;
            varying vec2 vUv;
            varying vec3 vBasePos;
            varying float vSunNoise;

            ${shaderUtils}

            void main() {
                vUv = uv;
                vec3 sphereP = normalize(position);
                vec3 absP = abs(position);
                float maxC = max(max(absP.x, absP.y), absP.z);
                vec3 boxP = position / maxC;
                vec3 baseDir = mix(sphereP, boxP, shapeFactor);
                vec3 basePos = baseDir * radius; 

                vBasePos = baseDir; 

                vec3 warpPos = sphereP * 0.5 + seedOffset;
                if (isSun > 0.5) warpPos += vec3(time * 0.1);

                float warp = snoise(warpPos) * warpScale;
                vec3 noisePos = (sphereP + vec3(warp)) * frequency + seedOffset;
                if (isSun > 0.5) noisePos += vec3(time * 0.2, -time*0.1, time*0.1);

                float n = fbm(noisePos, octaves, persistence, 2.0);
                float r = 1.0 - abs(snoise(noisePos));
                r = pow(r, 3.0); 
                float finalNoise = mix(n, r, ridge);
                
                vec2 sphericalUV = getUV(sphereP);
                float texHeight = texture2D(heightMap, sphericalUV).r;
                float combinedHeight = mix(finalNoise, texHeight * 2.0 - 1.0, texMix);
                
                float displacement = combinedHeight * heightScale;
                vec3 finalPos = basePos + normalize(baseDir) * displacement;
                
                vPos = finalPos; 
                vElevation = combinedHeight;
                vSunNoise = finalNoise; 

                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float oceanLevel;
            uniform float snowLevel;
            uniform float moistureOffset;
            uniform vec3 sunDirection; 
            uniform float time;
            uniform vec3 seedOffset;
            uniform float isSun;
            uniform float opacity;

            uniform vec3 oceanColor;
            uniform vec3 beachColor;
            uniform vec3 grassColor;
            uniform vec3 rockColor;
            uniform vec3 snowColor;

            varying vec3 vPos;
            varying vec3 vBasePos;
            varying float vElevation;
            varying float vSunNoise;
            
            ${shaderUtils}

            void main() {
                if (isSun > 0.5) {
                    float heat = vSunNoise * 0.5 + 0.5; 
                    float detail = snoise(vPos * 5.0 + vec3(time)) * 0.1;
                    heat += detail;
                    vec3 c1 = vec3(0.6, 0.0, 0.0); vec3 c2 = vec3(1.0, 0.4, 0.0); 
                    vec3 c3 = vec3(1.0, 0.9, 0.4); vec3 c4 = vec3(2.0, 2.0, 2.0); 
                    vec3 color;
                    if (heat < 0.33) color = mix(c1, c2, heat * 3.0);
                    else if (heat < 0.66) color = mix(c2, c3, (heat - 0.33) * 3.0);
                    else color = mix(c3, c4, (heat - 0.66) * 3.0);
                    vec3 N = normalize(vPos);
                    float rim = 1.0 - max(dot(N, vec3(0,0,1)), 0.0);
                    color += vec3(rim * 0.5, rim * 0.2, 0.0); 
                    gl_FragColor = vec4(color, opacity);
                    return;
                }

                vec3 N = normalize(vPos); 
                vec3 L = normalize(sunDirection); 
                float h = vElevation; 
                bool hasWater = oceanLevel > -0.99;
                vec3 color;
                float slope = 1.0 - dot(N, normalize(vBasePos));

                if (hasWater && h < oceanLevel) {
                    color = oceanColor;
                } else {
                    if (hasWater && h < oceanLevel + 0.015) color = beachColor;
                    else if (h > snowLevel) color = snowColor;
                    else {
                        float moist = snoise(normalize(vPos) * 2.5 + seedOffset) + moistureOffset;
                        if (slope > 0.18) color = rockColor;
                        else color = mix(grassColor * 0.4, grassColor, smoothstep(0.0, 0.6, moist));
                    }
                }
                float diff = max(dot(N, L), 0.0);
                vec3 finalColor = color * (diff * 0.8 + 0.2);
                gl_FragColor = vec4(finalColor, opacity);
            }
        `;

        function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return [(h1^h2^h3^h4)>>>0];
        }
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        // ============================================
        // PLANET LIBRARY SYSTEM
        // ============================================
        
        const planetLibrary = {
            suns: [],
            planets: [],
            moons: [],
            loaded: false,
            loading: false
        };
        
        async function loadPlanetLibrary() {
            if (planetLibrary.loading || planetLibrary.loaded) return;
            planetLibrary.loading = true;
            
            try {
                // Try to fetch manifest from planets folder
                const manifestResponse = await fetch('planets/manifest.json');
                if (!manifestResponse.ok) {
                    console.log('No planets/manifest.json found - using procedural generation');
                    planetLibrary.loading = false;
                    return;
                }
                
                const manifest = await manifestResponse.json();
                console.log(`Loading planet library: ${manifest.name}`);
                
                // Load each body ZIP file
                for (const filename of manifest.bodies) {
                    try {
                        const zipResponse = await fetch(`planets/${filename}`);
                        if (!zipResponse.ok) continue;
                        
                        const zipBlob = await zipResponse.blob();
                        const zip = await JSZip.loadAsync(zipBlob);
                        const jsonStr = await zip.file("planet_data.json").async("string");
                        const data = JSON.parse(jsonStr);
                        
                        // Load heightmap if present
                        let heightmapBase64 = null;
                        const imgFile = zip.file("heightmap.png");
                        if (imgFile) {
                            heightmapBase64 = await imgFile.async("base64");
                        }
                        
                        const bodyEntry = { data, heightmapBase64, filename };
                        
                        // Sort into appropriate category
                        if (data.type === 'sun') {
                            planetLibrary.suns.push(bodyEntry);
                        } else if (data.type === 'moon') {
                            planetLibrary.moons.push(bodyEntry);
                        } else {
                            planetLibrary.planets.push(bodyEntry);
                        }
                        
                        console.log(`  Loaded: ${filename} (${data.type})`);
                    } catch (err) {
                        console.warn(`Failed to load ${filename}:`, err);
                    }
                }
                
                planetLibrary.loaded = true;
                console.log(`Library loaded: ${planetLibrary.suns.length} suns, ${planetLibrary.planets.length} planets, ${planetLibrary.moons.length} moons`);
                
                // Update UI to show library status
                updateLibraryStatus();
                
            } catch (err) {
                console.log('Planet library not available:', err.message);
                updateLibraryStatus(); // Still update to show "procedural" mode
            }
            
            planetLibrary.loading = false;
        }
        
        function updateLibraryStatus() {
            const btn = $('btnRandomSystem');
            const suns = planetLibrary.suns.length;
            const planets = planetLibrary.planets.length;
            const moons = planetLibrary.moons.length;
            const total = suns + planets + moons;
            
            if (total > 0) {
                // Show library count with breakdown on hover
                btn.innerHTML = `ðŸŽ² Generate System <span style="font-size:9px;opacity:0.7;">(${total} in library)</span>`;
                btn.title = `Library: ${suns} sun(s), ${planets} planet(s), ${moons} moon(s)\nMissing types will be procedurally generated.`;
                btn.style.borderColor = '#00ff88';
            } else {
                // No library - purely procedural
                btn.innerHTML = `ðŸŽ² Generate Random System`;
                btn.title = `No planets/ folder found.\nAll bodies will be procedurally generated.`;
            }
        }
        
        function getLibraryBody(type, rng) {
            let pool;
            if (type === 'sun') pool = planetLibrary.suns;
            else if (type === 'moon') pool = planetLibrary.moons;
            else pool = planetLibrary.planets;
            
            if (pool.length === 0) return null;
            
            // Pick a random body from the library
            const idx = Math.floor(rng() * pool.length);
            const entry = pool[idx];
            
            // Clone the data so we don't modify the original
            return {
                data: JSON.parse(JSON.stringify(entry.data)),
                heightmapBase64: entry.heightmapBase64
            };
        }
        
        // Start loading library immediately
        loadPlanetLibrary();

        // --- CELESTIAL BODY CLASS ---
        class CelestialBody {
            constructor(data, texture, id, heightmapBase64 = null) {
                this.id = id;
                this.data = data;
                this.type = data.type || 'planet';
                this.name = `${this.type}_${data.seed}`;
                this.heightmapBase64 = heightmapBase64; // Store for export
                
                // HIERARCHY TRACKING
                this.parentBody = null; // null means scene/center
                this.childrenBodies = [];

                this.orbitDistance = 0;
                this.orbitSpeed = 0.2;
                this.orbitAngle = Math.random() * Math.PI * 2;
                
                const p = data.params;
                const c = data.colors;
                const seedHash = cyrb128(data.seed);
                const rng = mulberry32(seedHash[0]);
                const seedOffset = new THREE.Vector3(rng()*100, rng()*100, rng()*100);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        seedOffset: { value: seedOffset },
                        radius: { value: 1.0 },
                        heightScale: { value: parseFloat(p.heightScale) },
                        frequency: { value: parseFloat(p.frequency) },
                        octaves: { value: parseInt(p.octaves) },
                        persistence: { value: parseFloat(p.persistence) },
                        ridge: { value: parseFloat(p.ridge) },
                        warpScale: { value: parseFloat(p.warpScale) },
                        shapeFactor: { value: data.mode === 'cube' ? 0.7 : 0.0 }, 
                        oceanLevel: { value: parseFloat(p.oceanLevel) },
                        snowLevel: { value: parseFloat(p.snowLevel) },
                        moistureOffset: { value: parseFloat(p.moistureOffset) },
                        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                        time: { value: 0 },
                        heightMap: { value: texture },
                        texMix: { value: parseFloat(p.texMix || 0) },
                        oceanColor: { value: new THREE.Color(c.ocean) },
                        beachColor: { value: new THREE.Color(c.beach) },
                        grassColor: { value: new THREE.Color(c.grass) },
                        rockColor: { value: new THREE.Color(c.rock) },
                        snowColor: { value: new THREE.Color(c.snow) },
                        isSun: { value: this.type === 'sun' ? 1.0 : 0.0 },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    transparent: true
                });

                const geo = new THREE.BoxGeometry(1, 1, 1, 64, 64, 64);
                this.mesh = new THREE.Mesh(geo, this.material);
                
                // --- SIZE SCALING ---
                // We use the radius from the ZIP parameters.
                const baseRadius = parseFloat(p.radius);
                this.mesh.scale.setScalar(baseRadius);
                
                this.pivot = new THREE.Group(); 
                this.holder = new THREE.Group(); 
                
                this.pivot.add(this.holder);
                this.holder.add(this.mesh);

                const ringGeo = new THREE.RingGeometry(1, 1.05, 128);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x666666, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
                this.orbitRing = new THREE.Mesh(ringGeo, ringMat);
                this.orbitRing.rotation.x = Math.PI / 2;
            }

            setParent(newParent) {
                if (this.parentBody && this.parentBody.childrenBodies) {
                    const idx = this.parentBody.childrenBodies.indexOf(this);
                    if (idx > -1) this.parentBody.childrenBodies.splice(idx, 1);
                }

                this.parentBody = newParent; 

                if (newParent instanceof CelestialBody) {
                    newParent.childrenBodies.push(this);
                    newParent.holder.add(this.pivot); 
                    newParent.holder.add(this.orbitRing);
                } else {
                    scene.add(this.pivot);
                    scene.add(this.orbitRing);
                }

                this.pivot.position.set(0,0,0);
                this.pivot.rotation.set(0,0,0);
            }

            update(dt) {
                this.material.uniforms.time.value += dt;
                this.mesh.rotation.y += dt * 0.5;

                if (this.orbitDistance > 0.1) {
                    this.orbitAngle += this.orbitSpeed * dt * 0.5;
                    this.pivot.rotation.y = this.orbitAngle;
                    this.holder.position.set(this.orbitDistance, 0, 0);
                    this.orbitRing.visible = true;
                    this.orbitRing.scale.setScalar(this.orbitDistance);
                } else {
                    this.holder.position.set(0,0,0);
                    this.orbitRing.visible = false;
                }

                const worldPos = new THREE.Vector3();
                this.mesh.getWorldPosition(worldPos);
                const sunDir = worldPos.clone().multiplyScalar(-1).normalize();
                this.material.uniforms.sunDirection.value.copy(sunDir);
            }
            
            // Start catastrophic death spiral
            startDeathSpiral() {
                // Get current world position before detaching
                const worldPos = new THREE.Vector3();
                this.mesh.getWorldPosition(worldPos);
                
                // Remove from parent hierarchy
                this.pivot.removeFromParent();
                this.orbitRing.removeFromParent();
                
                // Add directly to scene at world position
                scene.add(this.mesh);
                this.mesh.position.copy(worldPos);
                
                // Random velocity direction (tangent to orbit + outward + some chaos)
                const outward = worldPos.clone().normalize();
                const tangent = new THREE.Vector3(-outward.z, 0, outward.x);
                const chaos = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 2
                );
                
                this.deathVelocity = tangent.multiplyScalar(15 + Math.random() * 10)
                    .add(outward.multiplyScalar(5 + Math.random() * 8))
                    .add(chaos.multiplyScalar(5));
                
                // Random tumble spin
                this.deathSpin = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                
                this.deathTime = 0;
                this.deathDuration = 3 + Math.random() * 2; // 3-5 seconds
                this.isDying = true;
            }
            
            // Update during death spiral
            updateDeath(dt) {
                if (!this.isDying) return false;
                
                this.deathTime += dt;
                const progress = this.deathTime / this.deathDuration;
                
                // Move outward with velocity
                this.mesh.position.add(this.deathVelocity.clone().multiplyScalar(dt));
                
                // Accelerate slightly (gravitational slingshot feel)
                this.deathVelocity.multiplyScalar(1 + dt * 0.3);
                
                // Tumble faster and faster
                this.mesh.rotation.x += this.deathSpin.x * dt * (1 + progress);
                this.mesh.rotation.y += this.deathSpin.y * dt * (1 + progress);
                this.mesh.rotation.z += this.deathSpin.z * dt * (1 + progress);
                
                // Fade out using shader uniform
                const opacity = Math.max(0, 1 - progress);
                this.material.uniforms.opacity.value = opacity;
                
                // Shrink slightly as it dies
                const scale = this.mesh.scale.x * (1 - dt * 0.2);
                this.mesh.scale.setScalar(Math.max(0.1, scale));
                
                // Return true if death is complete
                if (progress >= 1) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    return true; // Remove from dying list
                }
                return false;
            }
        }

        // --- APP STATE ---
        const bodies = []; 
        let selectedBody = null;
        let bodyCounter = 0;
        const dyingBodies = []; // Bodies in death spiral
        let hasEverAddedBody = false; // Track if user has ever added a body (for welcome screen)

        // --- UI LOGIC ---
        const $ = (id) => document.getElementById(id);
        const listEl = $('bodyList');
        const welcomeEl = $('welcome');

        $('btnImport').onclick = () => $('fileInput').click();

        // --- RANDOM GENERATION (matching PlanetEditor logic) ---
        function generateRandomName() {
            const prefixes = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Theta', 'Nova', 'Sol', 'Vega', 'Rigel', 'Sirius', 'Altair', 'Deneb', 'Polaris', 'Antares', 'Proxima', 'Kepler', 'Trappist', 'Gliese'];
            const suffixes = ['Prime', 'Major', 'Minor', 'X', 'IX', 'VII', 'III', 'IV', 'V', 'VI', 'A', 'B', 'C'];
            const numbers = ['', '-1', '-2', '-3', '-4', '-5', ' 47', ' 51', ' 186', ' 442'];
            return prefixes[Math.floor(Math.random() * prefixes.length)] + 
                   (Math.random() > 0.5 ? ' ' + suffixes[Math.floor(Math.random() * suffixes.length)] : '') +
                   numbers[Math.floor(Math.random() * numbers.length)];
        }

        function generateRandomBodyData(type, rng) {
            const seed = generateRandomName();
            
            // Base parameters (from PlanetEditor defaults)
            let params = {
                radius: type === 'sun' ? (1.2 + rng() * 0.8).toFixed(2) : 
                        type === 'moon' ? (0.3 + rng() * 0.3).toFixed(2) : 
                        (0.5 + rng() * 0.8).toFixed(2),
                warpScale: (rng() * 0.16).toFixed(2),
                heightScale: type === 'sun' ? '0.030' : (0.04 + rng() * 0.08).toFixed(3),
                frequency: (0.5 + rng() * 2.0).toFixed(2),
                octaves: Math.floor(3 + rng() * 4).toString(),
                persistence: (0.1 + rng() * 0.3).toFixed(2),
                ridge: (rng() * 0.3).toFixed(2),
                oceanLevel: type === 'sun' ? '-1.0' : 
                           type === 'moon' ? '-1.0' : 
                           (0.1 - rng() * 1.5).toFixed(2),
                snowLevel: (0.45 + rng() * 0.3).toFixed(2),
                moistureOffset: ((rng() - 0.5) * 0.6).toFixed(2),
                texMix: '0',
                waterNoise: type === 'planet',
                enableTrees: type === 'planet' && rng() > 0.3,
                treeDensity: type === 'planet' ? Math.floor(rng() * 60).toString() : '0',
                treeSize: '1.0'
            };
            
            // Generate colors based on type (from PlanetEditor randomizeBiomeColors)
            let colors;
            if (type === 'sun') {
                colors = {
                    ocean: '#ffaa00',
                    beach: '#ff8800',
                    grass: '#ff4400',
                    rock: '#aa2200',
                    snow: '#ffffaa'
                };
            } else if (type === 'moon') {
                colors = {
                    ocean: '#000000',
                    beach: '#' + new THREE.Color().setHSL(0, 0, 0.2 + rng() * 0.2).getHexString(),
                    grass: '#' + new THREE.Color().setHSL(0, 0, 0.3 + rng() * 0.2).getHexString(),
                    rock: '#' + new THREE.Color().setHSL(0, 0, 0.5 + rng() * 0.3).getHexString(),
                    snow: '#ffffff'
                };
            } else {
                const oceanH = 180 + rng() * 60;
                const beachH = 30 + rng() * 30;
                const grassH = rng() * 360;
                const rockH = rng() < 0.5 ? 30 + rng() * 20 : 0;
                colors = {
                    ocean: '#' + new THREE.Color().setHSL(oceanH / 360, 0.3 + rng() * 0.4, 0.65 + rng() * 0.2).getHexString(),
                    beach: '#' + new THREE.Color().setHSL(beachH / 360, 0.4 + rng() * 0.3, 0.75 + rng() * 0.15).getHexString(),
                    grass: '#' + new THREE.Color().setHSL(grassH / 360, 0.4 + rng() * 0.4, 0.3 + rng() * 0.3).getHexString(),
                    rock: '#' + new THREE.Color().setHSL(rockH / 360, 0.1 + rng() * 0.2, 0.4 + rng() * 0.2).getHexString(),
                    snow: '#' + new THREE.Color().setHSL(0, 0, 0.9 + rng() * 0.1).getHexString()
                };
            }
            
            return {
                seed: seed,
                type: type,
                mode: 'quad',
                hasHeightMap: false,
                params: params,
                colors: colors
            };
        }

        function generateRandomSolarSystem() {
            // Clear existing bodies
            while (bodies.length > 0) {
                const body = bodies.pop();
                body.pivot.removeFromParent();
                body.orbitRing.removeFromParent();
            }
            selectedBody = null;
            $('detailPanel').style.display = 'none';
            
            const masterSeed = Date.now();
            const seedHash = cyrb128(masterSeed.toString());
            const rng = mulberry32(seedHash[0]);
            
            // Helper: get body from library or generate procedurally
            function getOrGenerateBody(type) {
                const libraryBody = getLibraryBody(type, rng);
                if (libraryBody) {
                    // Use library body with its texture
                    let texture = null;
                    if (libraryBody.heightmapBase64) {
                        texture = new THREE.TextureLoader().load("data:image/png;base64," + libraryBody.heightmapBase64);
                    }
                    return { data: libraryBody.data, texture, heightmapBase64: libraryBody.heightmapBase64 };
                }
                // Fall back to procedural generation
                return { data: generateRandomBodyData(type, rng), texture: null, heightmapBase64: null };
            }
            
            // Generate sun (prefer library)
            const sun = getOrGenerateBody('sun');
            addBody(sun.data, sun.texture, sun.heightmapBase64);
            
            // Generate 2-6 planets
            const numPlanets = 2 + Math.floor(rng() * 5);
            for (let i = 0; i < numPlanets; i++) {
                const planet = getOrGenerateBody('planet');
                addBody(planet.data, planet.texture, planet.heightmapBase64);
                
                // 40% chance of having 1-3 moons
                if (rng() > 0.6) {
                    const numMoons = 1 + Math.floor(rng() * 3);
                    for (let j = 0; j < numMoons; j++) {
                        const moon = getOrGenerateBody('moon');
                        addBody(moon.data, moon.texture, moon.heightmapBase64);
                    }
                }
            }
            
            renderHierarchy();
        }

        $('btnRandomSystem').onclick = generateRandomSolarSystem;

        $('fileInput').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const zip = await JSZip.loadAsync(file);
                const jsonStr = await zip.file("planet_data.json").async("string");
                const data = JSON.parse(jsonStr);

                let texture = null;
                let heightmapBase64 = null;
                const imgFile = zip.file("heightmap.png");
                if (imgFile) {
                    heightmapBase64 = await imgFile.async("base64");
                    texture = new THREE.TextureLoader().load("data:image/png;base64," + heightmapBase64);
                }

                addBody(data, texture, heightmapBase64);
            } catch (err) {
                alert("Error loading ZIP: " + err);
            }
            $('fileInput').value = ""; 
        };

        function addBody(data, texture, heightmapBase64 = null) {
            // Mark that user has started using the editor
            hasEverAddedBody = true;
            
            // Hide welcome screen
            welcomeEl.classList.add('hidden');

            const body = new CelestialBody(data, texture, bodyCounter++, heightmapBase64);
            bodies.push(body);

            if (data.type === 'sun') {
                body.setParent(null); 
                body.orbitDistance = 0;
            } else if (data.type === 'moon') {
                const parent = findLastPlanet();
                if (parent) {
                    body.setParent(parent);
                    body.orbitDistance = 4 + parent.childrenBodies.length * 2.5; 
                } else {
                    body.setParent(null);
                    body.orbitDistance = 15; 
                }
            } else {
                body.setParent(null);
                const planets = bodies.filter(b => b.type === 'planet' && b.parentBody === null);
                body.orbitDistance = 15 + (planets.length * 15);
                body.orbitSpeed = 0.5 / (planets.length + 1);
            }

            renderHierarchy();
            selectBody(body);
        }

        function findLastPlanet() {
            for (let i = bodies.length - 2; i >= 0; i--) {
                if (bodies[i].type === 'planet') return bodies[i];
            }
            return null;
        }

        function renderHierarchy() {
            listEl.innerHTML = '';
            
            // Only show welcome if user has never added any body
            if (bodies.length === 0 && !hasEverAddedBody) {
                welcomeEl.classList.remove('hidden');
            } else {
                welcomeEl.classList.add('hidden');
            }

            const roots = bodies.filter(b => b.parentBody === null);
            roots.forEach(b => drawBodyItem(b, 0));
        }

        function drawBodyItem(body, depth) {
            const div = document.createElement('div');
            div.className = `body-item indent-${Math.min(depth, 2)}`;
            if (selectedBody === body) div.classList.add('selected');
            
            const c = body.data.colors.ocean;
            div.innerHTML = `
                <div style="display:flex; align-items:center;">
                    <span class="body-icon" style="background:${c}; color:${c}"></span>
                    <span>${body.data.seed} <span style="opacity:0.5; font-size:10px">(${body.type})</span></span>
                </div>
            `;
            div.onclick = () => selectBody(body);
            listEl.appendChild(div);

            if (body.childrenBodies.length > 0) {
                body.childrenBodies.forEach(child => drawBodyItem(child, depth + 1));
            }
        }

        function selectBody(body) {
            selectedBody = body;
            
            // Show panel if hidden
            $('detailPanel').style.display = 'flex';
            $('detailName').textContent = `${body.type.toUpperCase()} - ${body.data.seed}`;
            
            $('orbitDist').value = body.orbitDistance;
            $('distVal').textContent = body.orbitDistance.toFixed(1);

            $('orbitSpeed').value = body.orbitSpeed;
            $('speedVal').textContent = body.orbitSpeed.toFixed(2);
            
            updateParentDropdown(body);
            renderHierarchy();
        }

        function updateParentDropdown(currentBody) {
            const select = $('parentSelect');
            select.innerHTML = '<option value="null">System Center (Sun)</option>';
            
            bodies.forEach(b => {
                if (b === currentBody) return;
                if (isDescendant(currentBody, b)) return; 

                const option = document.createElement('option');
                option.value = b.id;
                option.textContent = `${b.type} - ${b.data.seed}`;
                if (currentBody.parentBody === b) option.selected = true;
                select.appendChild(option);
            });
            
            if (currentBody.parentBody === null) select.value = "null";
            
            select.onchange = (e) => {
                const val = e.target.value;
                if (val === "null") {
                    currentBody.setParent(null);
                } else {
                    const newParent = bodies.find(x => x.id == val);
                    if (newParent) currentBody.setParent(newParent);
                }
                renderHierarchy();
            };
        }

        function isDescendant(potentialAncestor, target) {
            if (target.parentBody === potentialAncestor) return true;
            if (target.parentBody) return isDescendant(potentialAncestor, target.parentBody);
            return false;
        }

        // Live Controls
        $('orbitDist').addEventListener('input', (e) => {
            if (selectedBody) {
                selectedBody.orbitDistance = parseFloat(e.target.value);
                $('distVal').textContent = selectedBody.orbitDistance.toFixed(1);
            }
        });
        $('orbitSpeed').addEventListener('input', (e) => {
            if (selectedBody) {
                selectedBody.orbitSpeed = parseFloat(e.target.value);
                $('speedVal').textContent = selectedBody.orbitSpeed.toFixed(2);
            }
        });
        
        $('btnDelete').onclick = () => {
            if (!selectedBody) return;
            
            // Check if we're deleting a sun - trigger catastrophe!
            if (selectedBody.type === 'sun') {
                // Collect all bodies that will be affected (everything orbiting the sun)
                const doomed = [];
                function collectDoomed(body) {
                    for (const child of body.childrenBodies) {
                        doomed.push(child);
                        collectDoomed(child); // Get moons too
                    }
                }
                collectDoomed(selectedBody);
                
                // Also get any bodies orbiting the system center (they orbit the sun implicitly)
                for (const body of bodies) {
                    if (body !== selectedBody && body.parentBody === null && body.type !== 'sun') {
                        doomed.push(body);
                        collectDoomed(body);
                    }
                }
                
                // Start death spiral for all doomed bodies
                for (const body of doomed) {
                    body.startDeathSpiral();
                    dyingBodies.push(body);
                    
                    // Remove from bodies array
                    const idx = bodies.indexOf(body);
                    if (idx > -1) bodies.splice(idx, 1);
                }
                
                // Now remove the sun itself
                selectedBody.pivot.removeFromParent();
                selectedBody.orbitRing.removeFromParent();
                const idx = bodies.indexOf(selectedBody);
                if (idx > -1) bodies.splice(idx, 1);
            } else {
                // Normal deletion for non-sun bodies
                selectedBody.pivot.removeFromParent();
                selectedBody.orbitRing.removeFromParent();
                
                const idx = bodies.indexOf(selectedBody);
                if (idx > -1) bodies.splice(idx, 1);
                
                if (selectedBody.parentBody) {
                    const childIdx = selectedBody.parentBody.childrenBodies.indexOf(selectedBody);
                    if (childIdx > -1) selectedBody.parentBody.childrenBodies.splice(childIdx, 1);
                }
                
                selectedBody.childrenBodies.forEach(child => {
                    child.setParent(null);
                });
            }

            selectedBody = null;
            focusedBody = null;
            $('body-label').style.display = 'none';
            $('detailPanel').style.display = 'none';
            renderHierarchy();
        };

        // --- EXPORT SOLAR SYSTEM ---
        $('btnExportSystem').onclick = async () => {
            if (bodies.length === 0) {
                alert("No bodies to export! Import some planets first.");
                return;
            }

            const masterZip = new JSZip();
            
            // Find the system name from the sun, or first body
            const sun = bodies.find(b => b.type === 'sun');
            const systemName = sun ? sun.data.seed : (bodies[0]?.data.seed || 'System');
            
            // Build the manifest with body references and orbital data
            const manifest = {
                name: systemName + ' System',
                distanceFromCore: 100,  // Default galactic position
                angle: 0,
                spiralArm: -1,
                bodies: []
            };
            
            // Process all bodies and create nested zips
            for (const body of bodies) {
                const bodyFilename = `${body.type}_${body.data.seed}.zip`;
                
                // Create a zip for this body
                const bodyZip = new JSZip();
                bodyZip.file("planet_data.json", JSON.stringify(body.data, null, 2));
                
                // Include heightmap if it exists
                if (body.heightmapBase64) {
                    bodyZip.file("heightmap.png", body.heightmapBase64, {base64: true});
                }
                
                // Generate the body zip and add to master zip
                const bodyBlob = await bodyZip.generateAsync({type: "blob"});
                masterZip.file(bodyFilename, bodyBlob);
                
                // Add to manifest with orbital data
                manifest.bodies.push({
                    file: bodyFilename,
                    type: body.type,
                    seed: body.data.seed,
                    orbitDistance: body.orbitDistance,
                    orbitSpeed: body.orbitSpeed,
                    parentId: body.parentBody ? body.parentBody.id : null
                });
            }
            
            // Add manifest to master zip
            masterZip.file("system_data.json", JSON.stringify(manifest, null, 2));
            
            // Generate and download
            const blob = await masterZip.generateAsync({type: "blob"});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `solarsystem_${systemName.replace(/\s+/g, '_')}.zip`;
            link.click();
        };

        // ============================================
        // ZOOM & CLICK-TO-FOCUS FEATURE
        // ============================================
        
        // State for body focus (separate from panel selection)
        let focusedBody = null;
        let savedCameraState = null;
        
        // Initial camera state for reset
        const initialCameraPosition = new THREE.Vector3(0, 40, 80);
        const initialCameraTarget = new THREE.Vector3(0, 0, 0);
        
        function updateZoomDisplay() {
            const dist = camera.position.length();
            const zoom = Math.round(80 / dist * 100);
            $('zoom-level').textContent = zoom + '%';
        }
        
        $('btnZoomIn').onclick = () => {
            camera.position.multiplyScalar(0.7);
            controls.update();
            updateZoomDisplay();
        };
        
        $('btnZoomOut').onclick = () => {
            camera.position.multiplyScalar(1.4);
            controls.update();
            updateZoomDisplay();
        };
        
        $('btnResetView').onclick = () => {
            // Deselect any focused body
            if (focusedBody) {
                deselectFocusedBody();
            }
            // Animate to initial view
            animateCameraToPosition(initialCameraPosition.clone(), initialCameraTarget.clone());
        };
        
        controls.addEventListener('change', updateZoomDisplay);
        
        // --- RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Body focus functions (for 3D click interaction)
        function selectFocusedBody(body) {
            // Save camera state before zooming
            savedCameraState = {
                position: camera.position.clone(),
                target: controls.target.clone()
            };
            
            focusedBody = body;
            
            // Also select in the panel
            selectBody(body);
            
            // Show label
            const bodyLabel = $('body-label');
            $('bodyLabelName').textContent = body.data.seed;
            $('bodyLabelType').textContent = body.type.charAt(0).toUpperCase() + body.type.slice(1);
            bodyLabel.style.display = 'block';
            
            // Animate camera to body
            animateCameraToBody(body);
        }
        
        function deselectFocusedBody() {
            if (!focusedBody) return;
            
            // Hide label
            $('body-label').style.display = 'none';
            
            // Restore camera
            if (savedCameraState) {
                animateCameraToPosition(savedCameraState.position, savedCameraState.target);
                savedCameraState = null;
            }
            
            focusedBody = null;
        }
        
        function getBodyWorldPosition(body) {
            const worldPos = new THREE.Vector3();
            body.mesh.getWorldPosition(worldPos);
            return worldPos;
        }
        
        function animateCameraToBody(body) {
            const targetPos = getBodyWorldPosition(body);
            
            // Calculate view distance based on body size
            const bodySize = body.mesh.scale.x;
            const viewDistance = Math.max(bodySize * 5, 8);
            
            // Calculate new camera position (offset from body)
            const offset = new THREE.Vector3(viewDistance * 0.7, viewDistance * 0.5, viewDistance * 0.7);
            const newCamPos = targetPos.clone().add(offset);
            
            animateCameraToPosition(newCamPos, targetPos);
        }
        
        function animateCameraToPosition(newPosition, newTarget) {
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 500;
            const startTime = performance.now();
            
            function animateCamera() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                
                camera.position.lerpVectors(startPos, newPosition, ease);
                controls.target.lerpVectors(startTarget, newTarget, ease);
                controls.update();
                updateZoomDisplay();
                
                if (t < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            animateCamera();
        }
        
        // Click handler for 3D view
        renderer.domElement.addEventListener('click', (e) => {
            if (e.target !== renderer.domElement) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Build list of clickable body meshes
            const clickables = bodies.map(b => ({ mesh: b.mesh, body: b }));
            
            const intersects = raycaster.intersectObjects(clickables.map(c => c.mesh));
            
            if (intersects.length > 0) {
                const hit = clickables.find(c => c.mesh === intersects[0].object);
                if (hit) {
                    selectFocusedBody(hit.body);
                }
            } else {
                // Clicked on empty space - deselect focused body
                if (focusedBody) {
                    deselectFocusedBody();
                }
            }
        });
        
        // ESC key handler
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (focusedBody) {
                    deselectFocusedBody();
                }
            }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            bodies.forEach(b => b.update(dt));
            
            // Update dying bodies (catastrophic death spiral)
            for (let i = dyingBodies.length - 1; i >= 0; i--) {
                const dead = dyingBodies[i].updateDeath(dt);
                if (dead) {
                    dyingBodies.splice(i, 1);
                }
            }
            
            // Track focused body with camera
            if (focusedBody && savedCameraState) {
                const targetPos = getBodyWorldPosition(focusedBody);
                controls.target.copy(targetPos);
            }
            
            controls.update();
            composer.render();
        }
        animate();
        updateZoomDisplay();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // EMBEDDED MODE SUPPORT
        // ============================================
        
        const isEmbedded = window.parent !== window || new URLSearchParams(window.location.search).has('embedded');
        let stagedPlanets = [];
        
        if (isEmbedded) {
            // Show embedded mode buttons
            $('btnReceivePlanets').style.display = 'block';
            $('btnSendToGalaxy').style.display = 'block';
            
            // Make regular import button smaller
            $('btnImport').style.fontSize = '10px';
            $('btnImport').style.padding = '6px';
            $('btnExportSystem').style.fontSize = '10px';
            $('btnExportSystem').style.padding = '6px';
            
            // Request staged planets on load
            window.parent.postMessage({ type: 'REQUEST_STAGED_PLANETS' }, '*');
        }
        
        // Receive planets from parent
        window.addEventListener('message', (event) => {
            const { type, data } = event.data || {};
            
            if (type === 'RECEIVE_PLANETS') {
                stagedPlanets = data || [];
                updateStagedCount();
            }
            
            if (type === 'EDITOR_ACTIVATED' && isEmbedded) {
                window.parent.postMessage({ type: 'REQUEST_STAGED_PLANETS' }, '*');
            }
        });
        
        function updateStagedCount() {
            const countEl = $('stagedCount');
            if (countEl) {
                countEl.textContent = stagedPlanets.length;
                $('btnReceivePlanets').style.opacity = stagedPlanets.length > 0 ? '1' : '0.5';
            }
        }
        
        // Import staged planets
        $('btnReceivePlanets').onclick = () => {
            if (stagedPlanets.length === 0) {
                alert('No planets staged! Create planets in the Planet Editor first and click "Send to System Editor".');
                return;
            }
            
            // Import each staged planet
            for (const planetData of stagedPlanets) {
                let texture = null;
                if (planetData.heightmapBase64) {
                    texture = new THREE.TextureLoader().load("data:image/png;base64," + planetData.heightmapBase64);
                }
                addBody(planetData, texture, planetData.heightmapBase64);
            }
            
            // Clear staged planets in parent
            window.parent.postMessage({ type: 'CLEAR_STAGED_PLANETS' }, '*');
            stagedPlanets = [];
            updateStagedCount();
            
            // Visual feedback
            const btn = $('btnReceivePlanets');
            btn.textContent = 'âœ“ Imported!';
            btn.style.background = 'linear-gradient(135deg, #00ff88, #00cc66)';
            setTimeout(() => {
                btn.innerHTML = 'ðŸ“¥ Import from Planet Editor <span id="stagedCount" style="background:#000;color:#ff6600;padding:2px 6px;border-radius:10px;margin-left:5px;font-size:10px;">0</span>';
            }, 1500);
        };
        
        // Get system data for export to Galaxy
        function getSystemData() {
            if (bodies.length === 0) return null;
            
            const sun = bodies.find(b => b.type === 'sun');
            const systemName = sun ? sun.data.seed : (bodies[0]?.data.seed || 'System');
            
            return {
                name: systemName + ' System',
                distanceFromCore: 100,
                angle: Math.random() * Math.PI * 2,
                spiralArm: -1,
                bodies: bodies.map(body => ({
                    data: body.data,
                    heightmapBase64: body.heightmapBase64,
                    type: body.type,
                    orbitDistance: body.orbitDistance,
                    orbitSpeed: body.orbitSpeed,
                    parentId: body.parentBody ? body.parentBody.id : null
                }))
            };
        }
        
        // Send to Galaxy Editor
        $('btnSendToGalaxy').onclick = () => {
            const systemData = getSystemData();
            if (!systemData) {
                alert('No bodies in system! Add some planets first.');
                return;
            }
            
            window.parent.postMessage({
                type: 'STAGE_SYSTEM',
                data: systemData
            }, '*');
            
            // Visual feedback
            const btn = $('btnSendToGalaxy');
            const originalText = btn.textContent;
            btn.textContent = 'âœ“ Staged!';
            btn.style.background = 'linear-gradient(135deg, #00ff88, #00cc66)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #9933ff, #cc66ff)';
            }, 1500);
        };
    </script>
</body>
</html>