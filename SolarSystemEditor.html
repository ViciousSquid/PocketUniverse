<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solar System Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root { --accent: #00ff88; --panel: rgba(10, 10, 12, 0.95); --border: rgba(255,255,255,0.1); }
        body { margin: 0; overflow: hidden; background: #000; color: #e0e0e0; font-family: 'Segoe UI', Roboto, sans-serif; font-size: 13px; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        .panel { 
            pointer-events: auto; background: var(--panel); backdrop-filter: blur(12px); 
            width: 300px; padding: 0; border-radius: 8px; border: 1px solid var(--border); 
            display: flex; flex-direction: column; 
            max-height: 90vh; transition: height 0.3s;
            box-shadow: 0 8px 40px rgba(0,0,0,0.8); 
            overflow: hidden; /* Important for collapse animation */
        }
        
        /* Collapsed State */
        .panel.collapsed { width: auto; max-height: 48px; }
        .panel.collapsed .panel-content { display: none; }
        .panel.collapsed .collapse-btn { transform: rotate(180deg); }

        /* Header Styling */
        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; cursor: pointer; background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border); user-select: none;
        }
        .panel-header:hover h2 { color: #fff; text-shadow: 0 0 8px var(--accent); }

        .collapse-btn {
            background: none; border: 1px solid #444; color: #888; width: 24px; height: 24px;
            border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center;
            justify-content: center; transition: all 0.2s; padding: 0;
        }
        .collapse-btn:hover { background: #333; color: #fff; border-color: #666; }

        .panel-content { padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }

        h2 { margin: 0; font-size: 14px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; font-weight: 800; }
        h3 { margin: 10px 0 5px 0; font-size: 11px; color: #888; text-transform: uppercase; }
        
        /* General Controls */
        button.action-btn { background: #222; color: #fff; border: 1px solid #444; padding: 10px; border-radius: 4px; cursor: pointer; transition: 0.2s; text-transform: uppercase; font-size: 11px; font-weight: bold; width: 100%; }
        button.action-btn:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        button.delete-btn { background: #422; border-color: #633; margin-top: 5px; }
        button.delete-btn:hover { background: #f44; color: #fff; }

        /* Hierarchy List Styling */
        .body-list { display: flex; flex-direction: column; gap: 2px; }
        .body-item { padding: 6px 8px; background: rgba(255,255,255,0.05); border-radius: 4px; cursor: pointer; display: flex; align-items: center; border: 1px solid transparent; transition: all 0.1s; }
        .body-item:hover { background: rgba(255,255,255,0.1); }
        .body-item.selected { border-color: var(--accent); background: rgba(0, 255, 136, 0.1); }
        .body-icon { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 4px currentColor; }
        
        .indent-0 { margin-left: 0px; border-left: 2px solid #444; }
        .indent-1 { margin-left: 20px; border-left: 2px solid #666; }
        .indent-2 { margin-left: 40px; border-left: 2px solid #888; }

        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        input[type=range] { width: 100%; accent-color: var(--accent); cursor: pointer; margin: 4px 0; }
        select { width: 100%; background: #222; color: #fff; border: 1px solid #444; padding: 6px; border-radius: 4px; margin-top: 4px; }
        .val { font-family: monospace; color: var(--accent); }
        
        #fileInput { display: none; }

        /* WELCOME SCREEN */
        #welcome {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; text-align: center; color: #fff; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 40px; border-radius: 16px; border: 1px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 5;
            transition: opacity 0.5s;
        }
        #welcome.hidden { opacity: 0; pointer-events: none; }
        #welcome h1 { margin: 0 0 10px 0; color: var(--accent); font-weight: 300; letter-spacing: 4px; text-transform: uppercase; }
        #welcome p { color: #888; line-height: 1.6; font-size: 14px; }
        .step { background: #222; padding: 10px; margin: 10px 0; border-radius: 4px; border: 1px solid #333; display: flex; align-items: center; gap: 10px; text-align: left; }
        .step-num { background: var(--accent); color: #000; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="welcome">
        <h1>System Editor</h1>
        <p>Assemble your generated planets into a complete solar system.</p>
        
        <div class="step">
            <div class="step-num">1</div>
            <div><strong>Import Sun:</strong> Start by importing your <em>sun_*.zip</em> file to act as the center.</div>
        </div>
        <div class="step">
            <div class="step-num">2</div>
            <div><strong>Add Planets:</strong> Import <em>planet_*.zip</em> files. They will automatically orbit the sun.</div>
        </div>
        <div class="step">
            <div class="step-num">3</div>
            <div><strong>Add Moons:</strong> Import <em>moon_*.zip</em> files. They will attach to the last planet added.</div>
        </div>
        <p style="margin-top:20px; font-size: 12px; color: #666;">Use the <strong>hierarchy panel</strong> on the left to reorganize orbits.</p>
    </div>

    <div id="ui-layer">
        <div class="panel" id="leftPanel">
            <div class="panel-header" onclick="togglePanel('leftPanel')">
                <h2>Hierarchy</h2>
                <button class="collapse-btn">â–¼</button>
            </div>
            <div class="panel-content">
                <button id="btnImport" class="action-btn">âž• Import Body (ZIP)</button>
                <button id="btnExportSystem" class="action-btn" style="background:#264; border-color:#3a6; margin-top:5px;">ðŸ’¾ Export Solar System</button>
                <input type="file" id="fileInput" accept=".zip">
                <div id="bodyList" class="body-list">
                    </div>
            </div>
        </div>

        <div class="panel" id="detailPanel" style="display:none;">
            <div class="panel-header" onclick="togglePanel('detailPanel')">
                <h2 id="detailName">Details</h2>
                <button class="collapse-btn">â–¼</button>
            </div>
            
            <div class="panel-content">
                <h3>Hierarchy</h3>
                <div style="margin-bottom: 10px;">
                    <label style="color:#bbb;">Orbiting Parent</label>
                    <select id="parentSelect"></select>
                </div>

                <h3>Orbital Mechanics</h3>
                <div class="control-row"><label>Distance</label><span id="distVal" class="val">0</span></div>
                <input type="range" id="orbitDist" min="0" max="150" step="0.5">
                
                <div class="control-row"><label>Orbit Speed</label><span id="speedVal" class="val">0</span></div>
                <input type="range" id="orbitSpeed" min="0" max="3.0" step="0.01">

                <button class="action-btn delete-btn" id="btnDelete">Remove Object</button>
            </div>
        </div>
    </div>

    <script>
        function togglePanel(id) {
            const panel = document.getElementById(id);
            panel.classList.toggle('collapsed');
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GLOBAL SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 40, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // Starfield
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(5000 * 3);
        for(let i=0; i<5000*3; i++) starPos[i] = (Math.random() - 0.5) * 1000;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.3, transparent: true, opacity: 0.6})));

        // Lights
        const sunLight = new THREE.PointLight(0xffffff, 2, 500);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        // --- SHADER UTILS ---
        const shaderUtils = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
            float fbm(vec3 p, int octaves, float persistence, float lacunarity) {
                float total = 0.0; float amplitude = 1.0; float frequency = 1.0; float maxValue = 0.0;
                for(int i=0; i<20; i++) {
                    if (i >= octaves) break;
                    total += snoise(p * frequency) * amplitude;
                    maxValue += amplitude; amplitude *= persistence; frequency *= lacunarity;
                }
                return total / maxValue;
            }
            vec2 getUV(vec3 p) {
                vec3 n = normalize(p);
                float u = 0.5 + (atan(n.z, n.x) / (2.0 * 3.14159));
                float v = 0.5 - (asin(n.y) / 3.14159);
                return vec2(u, v);
            }
        `;

        const vertexShader = `
            uniform float radius;
            uniform float heightScale;
            uniform float frequency;
            uniform int octaves;
            uniform float persistence;
            uniform float ridge;
            uniform float warpScale;
            uniform vec3 seedOffset;
            uniform float shapeFactor; 
            uniform sampler2D heightMap;
            uniform float texMix;
            uniform float isSun;
            uniform float time;

            varying vec3 vPos;
            varying float vElevation;
            varying vec2 vUv;
            varying vec3 vBasePos;
            varying float vSunNoise;

            ${shaderUtils}

            void main() {
                vUv = uv;
                vec3 sphereP = normalize(position);
                vec3 absP = abs(position);
                float maxC = max(max(absP.x, absP.y), absP.z);
                vec3 boxP = position / maxC;
                vec3 baseDir = mix(sphereP, boxP, shapeFactor);
                vec3 basePos = baseDir * radius; 

                vBasePos = baseDir; 

                vec3 warpPos = sphereP * 0.5 + seedOffset;
                if (isSun > 0.5) warpPos += vec3(time * 0.1);

                float warp = snoise(warpPos) * warpScale;
                vec3 noisePos = (sphereP + vec3(warp)) * frequency + seedOffset;
                if (isSun > 0.5) noisePos += vec3(time * 0.2, -time*0.1, time*0.1);

                float n = fbm(noisePos, octaves, persistence, 2.0);
                float r = 1.0 - abs(snoise(noisePos));
                r = pow(r, 3.0); 
                float finalNoise = mix(n, r, ridge);
                
                vec2 sphericalUV = getUV(sphereP);
                float texHeight = texture2D(heightMap, sphericalUV).r;
                float combinedHeight = mix(finalNoise, texHeight * 2.0 - 1.0, texMix);
                
                float displacement = combinedHeight * heightScale;
                vec3 finalPos = basePos + normalize(baseDir) * displacement;
                
                vPos = finalPos; 
                vElevation = combinedHeight;
                vSunNoise = finalNoise; 

                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float oceanLevel;
            uniform float snowLevel;
            uniform float moistureOffset;
            uniform vec3 sunDirection; 
            uniform float time;
            uniform vec3 seedOffset;
            uniform float isSun;

            uniform vec3 oceanColor;
            uniform vec3 beachColor;
            uniform vec3 grassColor;
            uniform vec3 rockColor;
            uniform vec3 snowColor;

            varying vec3 vPos;
            varying vec3 vBasePos;
            varying float vElevation;
            varying float vSunNoise;
            
            ${shaderUtils}

            void main() {
                if (isSun > 0.5) {
                    float heat = vSunNoise * 0.5 + 0.5; 
                    float detail = snoise(vPos * 5.0 + vec3(time)) * 0.1;
                    heat += detail;
                    vec3 c1 = vec3(0.6, 0.0, 0.0); vec3 c2 = vec3(1.0, 0.4, 0.0); 
                    vec3 c3 = vec3(1.0, 0.9, 0.4); vec3 c4 = vec3(2.0, 2.0, 2.0); 
                    vec3 color;
                    if (heat < 0.33) color = mix(c1, c2, heat * 3.0);
                    else if (heat < 0.66) color = mix(c2, c3, (heat - 0.33) * 3.0);
                    else color = mix(c3, c4, (heat - 0.66) * 3.0);
                    vec3 N = normalize(vPos);
                    float rim = 1.0 - max(dot(N, vec3(0,0,1)), 0.0);
                    color += vec3(rim * 0.5, rim * 0.2, 0.0); 
                    gl_FragColor = vec4(color, 1.0);
                    return;
                }

                vec3 N = normalize(vPos); 
                vec3 L = normalize(sunDirection); 
                float h = vElevation; 
                bool hasWater = oceanLevel > -0.99;
                vec3 color;
                float slope = 1.0 - dot(N, normalize(vBasePos));

                if (hasWater && h < oceanLevel) {
                    color = oceanColor;
                } else {
                    if (hasWater && h < oceanLevel + 0.015) color = beachColor;
                    else if (h > snowLevel) color = snowColor;
                    else {
                        float moist = snoise(normalize(vPos) * 2.5 + seedOffset) + moistureOffset;
                        if (slope > 0.18) color = rockColor;
                        else color = mix(grassColor * 0.4, grassColor, smoothstep(0.0, 0.6, moist));
                    }
                }
                float diff = max(dot(N, L), 0.0);
                vec3 finalColor = color * (diff * 0.8 + 0.2);
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return [(h1^h2^h3^h4)>>>0];
        }
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        // --- CELESTIAL BODY CLASS ---
        class CelestialBody {
            constructor(data, texture, id) {
                this.id = id;
                this.data = data;
                this.type = data.type || 'planet';
                this.name = `${this.type}_${data.seed}`;
                
                // HIERARCHY TRACKING
                this.parentBody = null; // null means scene/center
                this.childrenBodies = [];

                this.orbitDistance = 0;
                this.orbitSpeed = 0.2;
                this.orbitAngle = Math.random() * Math.PI * 2;
                
                const p = data.params;
                const c = data.colors;
                const seedHash = cyrb128(data.seed);
                const rng = mulberry32(seedHash[0]);
                const seedOffset = new THREE.Vector3(rng()*100, rng()*100, rng()*100);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        seedOffset: { value: seedOffset },
                        radius: { value: 1.0 },
                        heightScale: { value: parseFloat(p.heightScale) },
                        frequency: { value: parseFloat(p.frequency) },
                        octaves: { value: parseInt(p.octaves) },
                        persistence: { value: parseFloat(p.persistence) },
                        ridge: { value: parseFloat(p.ridge) },
                        warpScale: { value: parseFloat(p.warpScale) },
                        shapeFactor: { value: data.mode === 'cube' ? 0.7 : 0.0 }, 
                        oceanLevel: { value: parseFloat(p.oceanLevel) },
                        snowLevel: { value: parseFloat(p.snowLevel) },
                        moistureOffset: { value: parseFloat(p.moistureOffset) },
                        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                        time: { value: 0 },
                        heightMap: { value: texture },
                        texMix: { value: parseFloat(p.texMix || 0) },
                        oceanColor: { value: new THREE.Color(c.ocean) },
                        beachColor: { value: new THREE.Color(c.beach) },
                        grassColor: { value: new THREE.Color(c.grass) },
                        rockColor: { value: new THREE.Color(c.rock) },
                        snowColor: { value: new THREE.Color(c.snow) },
                        isSun: { value: this.type === 'sun' ? 1.0 : 0.0 }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader
                });

                const geo = new THREE.BoxGeometry(1, 1, 1, 64, 64, 64);
                this.mesh = new THREE.Mesh(geo, this.material);
                
                // --- SIZE SCALING ---
                // We use the radius from the ZIP parameters.
                const baseRadius = parseFloat(p.radius);
                this.mesh.scale.setScalar(baseRadius);
                
                this.pivot = new THREE.Group(); 
                this.holder = new THREE.Group(); 
                
                this.pivot.add(this.holder);
                this.holder.add(this.mesh);

                const ringGeo = new THREE.RingGeometry(1, 1.05, 128);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x666666, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
                this.orbitRing = new THREE.Mesh(ringGeo, ringMat);
                this.orbitRing.rotation.x = Math.PI / 2;
            }

            setParent(newParent) {
                if (this.parentBody && this.parentBody.childrenBodies) {
                    const idx = this.parentBody.childrenBodies.indexOf(this);
                    if (idx > -1) this.parentBody.childrenBodies.splice(idx, 1);
                }

                this.parentBody = newParent; 

                if (newParent instanceof CelestialBody) {
                    newParent.childrenBodies.push(this);
                    newParent.holder.add(this.pivot); 
                    newParent.holder.add(this.orbitRing);
                } else {
                    scene.add(this.pivot);
                    scene.add(this.orbitRing);
                }

                this.pivot.position.set(0,0,0);
                this.pivot.rotation.set(0,0,0);
            }

            update(dt) {
                this.material.uniforms.time.value += dt;
                this.mesh.rotation.y += dt * 0.5;

                if (this.orbitDistance > 0.1) {
                    this.orbitAngle += this.orbitSpeed * dt * 0.5;
                    this.pivot.rotation.y = this.orbitAngle;
                    this.holder.position.set(this.orbitDistance, 0, 0);
                    this.orbitRing.visible = true;
                    this.orbitRing.scale.setScalar(this.orbitDistance);
                } else {
                    this.holder.position.set(0,0,0);
                    this.orbitRing.visible = false;
                }

                const worldPos = new THREE.Vector3();
                this.mesh.getWorldPosition(worldPos);
                const sunDir = worldPos.clone().multiplyScalar(-1).normalize();
                this.material.uniforms.sunDirection.value.copy(sunDir);
            }
        }

        // --- APP STATE ---
        const bodies = []; 
        let selectedBody = null;
        let bodyCounter = 0;

        // --- UI LOGIC ---
        const $ = (id) => document.getElementById(id);
        const listEl = $('bodyList');
        const welcomeEl = $('welcome');

        $('btnImport').onclick = () => $('fileInput').click();

        $('fileInput').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const zip = await JSZip.loadAsync(file);
                const jsonStr = await zip.file("planet_data.json").async("string");
                const data = JSON.parse(jsonStr);

                let texture = null;
                const imgFile = zip.file("heightmap.png");
                if (imgFile) {
                    const b64 = await imgFile.async("base64");
                    texture = new THREE.TextureLoader().load("data:image/png;base64," + b64);
                }

                addBody(data, texture);
            } catch (err) {
                alert("Error loading ZIP: " + err);
            }
            $('fileInput').value = ""; 
        };

        function addBody(data, texture) {
            // Hide welcome screen on first import
            if (bodies.length === 0) {
                welcomeEl.classList.add('hidden');
            }

            const body = new CelestialBody(data, texture, bodyCounter++);
            bodies.push(body);

            if (data.type === 'sun') {
                body.setParent(null); 
                body.orbitDistance = 0;
            } else if (data.type === 'moon') {
                const parent = findLastPlanet();
                if (parent) {
                    body.setParent(parent);
                    body.orbitDistance = 4 + parent.childrenBodies.length * 2.5; 
                } else {
                    body.setParent(null);
                    body.orbitDistance = 15; 
                }
            } else {
                body.setParent(null);
                const planets = bodies.filter(b => b.type === 'planet' && b.parentBody === null);
                body.orbitDistance = 15 + (planets.length * 15);
                body.orbitSpeed = 0.5 / (planets.length + 1);
            }

            renderHierarchy();
            selectBody(body);
        }

        function findLastPlanet() {
            for (let i = bodies.length - 2; i >= 0; i--) {
                if (bodies[i].type === 'planet') return bodies[i];
            }
            return null;
        }

        function renderHierarchy() {
            listEl.innerHTML = '';
            
            // Show welcome if empty
            if (bodies.length === 0) {
                welcomeEl.classList.remove('hidden');
            } else {
                welcomeEl.classList.add('hidden');
            }

            const roots = bodies.filter(b => b.parentBody === null);
            roots.forEach(b => drawBodyItem(b, 0));
        }

        function drawBodyItem(body, depth) {
            const div = document.createElement('div');
            div.className = `body-item indent-${Math.min(depth, 2)}`;
            if (selectedBody === body) div.classList.add('selected');
            
            const c = body.data.colors.ocean;
            div.innerHTML = `
                <div style="display:flex; align-items:center;">
                    <span class="body-icon" style="background:${c}; color:${c}"></span>
                    <span>${body.data.seed} <span style="opacity:0.5; font-size:10px">(${body.type})</span></span>
                </div>
            `;
            div.onclick = () => selectBody(body);
            listEl.appendChild(div);

            if (body.childrenBodies.length > 0) {
                body.childrenBodies.forEach(child => drawBodyItem(child, depth + 1));
            }
        }

        function selectBody(body) {
            selectedBody = body;
            
            // Show panel if hidden
            $('detailPanel').style.display = 'flex';
            $('detailName').textContent = `${body.type.toUpperCase()} - ${body.data.seed}`;
            
            $('orbitDist').value = body.orbitDistance;
            $('distVal').textContent = body.orbitDistance.toFixed(1);

            $('orbitSpeed').value = body.orbitSpeed;
            $('speedVal').textContent = body.orbitSpeed.toFixed(2);
            
            updateParentDropdown(body);
            renderHierarchy();
        }

        function updateParentDropdown(currentBody) {
            const select = $('parentSelect');
            select.innerHTML = '<option value="null">System Center (Sun)</option>';
            
            bodies.forEach(b => {
                if (b === currentBody) return;
                if (isDescendant(currentBody, b)) return; 

                const option = document.createElement('option');
                option.value = b.id;
                option.textContent = `${b.type} - ${b.data.seed}`;
                if (currentBody.parentBody === b) option.selected = true;
                select.appendChild(option);
            });
            
            if (currentBody.parentBody === null) select.value = "null";
            
            select.onchange = (e) => {
                const val = e.target.value;
                if (val === "null") {
                    currentBody.setParent(null);
                } else {
                    const newParent = bodies.find(x => x.id == val);
                    if (newParent) currentBody.setParent(newParent);
                }
                renderHierarchy();
            };
        }

        function isDescendant(potentialAncestor, target) {
            if (target.parentBody === potentialAncestor) return true;
            if (target.parentBody) return isDescendant(potentialAncestor, target.parentBody);
            return false;
        }

        // Live Controls
        $('orbitDist').addEventListener('input', (e) => {
            if (selectedBody) {
                selectedBody.orbitDistance = parseFloat(e.target.value);
                $('distVal').textContent = selectedBody.orbitDistance.toFixed(1);
            }
        });
        $('orbitSpeed').addEventListener('input', (e) => {
            if (selectedBody) {
                selectedBody.orbitSpeed = parseFloat(e.target.value);
                $('speedVal').textContent = selectedBody.orbitSpeed.toFixed(2);
            }
        });
        
        $('btnDelete').onclick = () => {
            if (!selectedBody) return;
            selectedBody.pivot.removeFromParent();
            selectedBody.orbitRing.removeFromParent();
            
            const idx = bodies.indexOf(selectedBody);
            if (idx > -1) bodies.splice(idx, 1);
            
            if (selectedBody.parentBody) {
                const childIdx = selectedBody.parentBody.childrenBodies.indexOf(selectedBody);
                if (childIdx > -1) selectedBody.parentBody.childrenBodies.splice(childIdx, 1);
            }
            
            selectedBody.childrenBodies.forEach(child => {
                child.setParent(null);
            });

            selectedBody = null;
            $('detailPanel').style.display = 'none';
            renderHierarchy();
        };

        // --- EXPORT SOLAR SYSTEM ---
        $('btnExportSystem').onclick = async () => {
            if (bodies.length === 0) {
                alert('No bodies to export! Import some planets first.');
                return;
            }

            const zip = new JSZip();
            
            // Find the sun to name the system
            const sun = bodies.find(b => b.type === 'sun');
            const systemName = sun ? sun.data.seed : 'Unknown';
            
            // Build hierarchy data
            function buildHierarchy(body) {
                return {
                    file: `${body.type}_${body.data.seed}.zip`,
                    orbitDistance: body.orbitDistance,
                    orbitSpeed: body.orbitSpeed,
                    children: body.childrenBodies.map(child => buildHierarchy(child))
                };
            }
            
            const rootBodies = bodies.filter(b => b.parentBody === null);
            
            const systemData = {
                name: systemName + ' System',
                version: '1.0',
                bodies: rootBodies.map(b => buildHierarchy(b))
            };
            
            zip.file("system_data.json", JSON.stringify(systemData, null, 2));
            
            // Add each body as a nested ZIP
            for (const body of bodies) {
                const bodyZip = new JSZip();
                bodyZip.file("planet_data.json", JSON.stringify(body.data, null, 2));
                
                // Note: heightmap textures would need to be stored separately
                // For now we just include the JSON data
                
                const bodyBlob = await bodyZip.generateAsync({ type: "blob" });
                zip.file(`${body.type}_${body.data.seed}.zip`, bodyBlob);
            }
            
            const blob = await zip.generateAsync({ type: "blob" });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `solarsystem_${systemName}.zip`;
            link.click();
        };

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            bodies.forEach(b => b.update(dt));
            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>